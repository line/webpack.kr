---
title: Module
sort: 7
contributors:
  - sokra
  - skipjack
  - jouni-kantola
  - jhnns
  - dylanonelson
  - byzyk
  - pnevares
  - fadysamirsadek
  - nerdkid93
  - EugeneHlushko
  - superburrito
  - lukasgeiter
  - skovy
  - smelukov
  - opl-
  - Mistyyyy
  - anshumanv
  - chenxsan
translators:
  - YukJiSoo
---

이 옵션은 프로젝트 내에서 [다른 유형의 모듈](/concepts/modules)을 처리하는 방법을 결정합니다.

## module.generator

<Badge text="5.12.0+" />

`module.generator`를 사용하여 한 곳에서 모든 제너레이터의 옵션을 설정할 수 있습니다.

**webpack.config.js**

```js
module.exports = {
  module: {
    generator: {
      asset: {
        // asset 모듈 제너레이터 옵션

        // asset 모듈을 위한 publicPath 사용자 정의. webpack 5.28.0 이후로 사용 가능.
        publicPath: 'assets/',
      },
      'asset/inline': {
        // asset/inline 모듈 제너레이터 옵션
      },
      'asset/resource': {
        // asset/resource 모듈 제너레이터 옵션

        // asset/resource 모듈을 위한 publicPath 사용자 정의. webpack 5.28.0 이후로 사용 가능.
        publicPath: 'assets/',
      },
      javascript: {
        // 이 모듈 유형에는 아직 제너레이터 옵션이 지원되지 않습니다.
      },
      'javascript/auto': {
        // 위와 동일
      },
      'javascript/dynamic': {
        // 위와 동일
      },
      'javascript/esm': {
        // 위와 동일
      },
      // 그외 다른 옵션들…
    },
  },
};
```

## module.parser

<Badge text="5.12.0+" />

[`module.generator`](#modulegenerator)처럼 `module.parser`를 사용하여 한 곳에서 모든 파서의 옵션을 설정할 수 있습니다.

**webpack.config.js**

```js
module.exports = {
  module: {
    parser: {
      asset: {
        // asset 모듈 파서 옵션
      },
      'asset/inline': {
        // 이 모듈 유형에는 아직 파서 옵션이 지원되지 않습니다.
      },
      'asset/resource': {
        // 위와 동일
      },
      'asset/source': {
        // 위와 동일
      },
      javascript: {
        // javascript 모듈 파서 옵션
        // 예. require.ensure 구문 파싱 활성화
        requireEnsure: true,
      },
      'javascript/auto': {
        // 위와 동일
      },
      'javascript/dynamic': {
        // 위와 동일
      },
      'javascript/esm': {
        // 위와 동일
      },
      // 그외 다른 옵션들…
    },
  },
};
```

### module.parser.javascript

JavaScript 파서를 위한 옵션을 설정할 수 있습니다.

```js
module.exports = {
  module: {
    parser: {
      javascript: {
        // ...
        commonjsMagicComments: true,
      },
    },
  },
};
```

[`Rule.parser`](/configuration/module/#ruleparser)에서 이러한 옵션을 설정하고 특정 모듈을 대상으로 지정할 수 있습니다.

#### module.parser.javascript.commonjsMagicComments

CommonJS를 위해 [magic comments](/api/module-methods/#magic-comments)지원을 활성화할 수 있습니다.

- 타입: `boolean`
- 가능한 버전: 5.17.0+
- 예제:
  ```js
  module.exports = {
    module: {
      parser: {
        javascript: {
          commonjsMagicComments: true,
        },
      },
    },
  };
  ```

`webpackIgnore` 주석만 지원됩니다.

```js
const x = require(/* webpackIgnore: true */ 'x');
```

#### module.parser.javascript.url

`new URL()` 구문 파싱을 활성화합니다.

- 타입: `boolean = true` | `'relative'`
- 예제:
  ```js
  module.exports = {
    module: {
      parser: {
        javascript: {
          url: false, // `new URL()` 구문 파싱 비활성화
        },
      },
    },
  };
  ```

`module.parser.javascript.url`의 `'relative'` 값은 webpack <Badge text='5.23.0' />부터 사용할 수 있습니다. 사용하면 webpack은 `new URL()` 구문에 대한 상대경로 URL을 생성합니다. 즉, 결과 URL 기준 URL이 포함되지 않습니다.

```
<!-- 'relative'인 경우 -->
<img src='c43188443804f1b1f534.svg' />

<!-- 'relative'가 아닌 경우 -->
<img src='file:///path/to/project/dist/c43188443804f1b1f534.svg' />
```

1. 이것은 기준 URL이 서버에의 알려지지 않을 때 SSR(서버 사이드 렌더링)에 유용하며 몇 바이트를 절약할 수 있습니다. 동일하게 유지하기 위해서 클라이언트 빌드에서도 사용해야 합니다.
2. 또한 서버 측 렌더링이 일반적으로 필요한 정적 사이트 생성기, mini-css-plugin 및 html-plugin 등을 위해서도 필요합니다.

## module.noParse

`RegExp` `[RegExp]` `function(resource)` `string` `[string]`

webpack이 주어진 정규식과 일치하는 파일을 파싱하지 못하도록 합니다. 제외된 파일에는 `import`, `require`, `define` 또는 기타 import 메커니즘의 호출이 **없어야 합니다**. 이렇게 하면 큰 라이브러리를 무시할 때 빌드 성능을 향상 시킬 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    noParse: /jquery|lodash/,
  },
};
```

```javascript
module.exports = {
  //...
  module: {
    noParse: (content) => /jquery|lodash/.test(content),
  },
};
```

## module.unsafeCache

`boolean` `function (module)`

모듈 요청에 대한 해석을 캐시합니다. `module.unsafeCache`에 대한 몇 가지 기본값이 있습니다.

- [`cache`](/configuration/cache)가 비활성화되어 있다면 `false`
- [`cache`](/configuration/cache)가 활성화되어 있고 모듈이 node 모듈에서 온 것으로 보인다면 `true`, 그렇지 않다면 `false`

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    unsafeCache: false,
  },
};
```

## module.rules

`[Rule]`

모듈이 생성 될 때 요청과 일치하는 [Rule](#rule)의 배열입니다. 이러한 규칙은 모듈 생성 방법을 수정할 수 있습니다. 로더를 모듈에 적용시키거나 파서를 수정할 수 있습니다.

## Rule

`object`

Rule은 Conditions, Results 그리고 중첩된 Rules 세 부분으로 나눠질 수 있습니다.

### Rule Conditions

conditions에 대한 두가지 입력 값이 있습니다.

1. resource: 요청된 파일의 절대 경로입니다. [`resolve` 규칙](/configuration/resolve)에 따라 이미 해석되었습니다.

2. issuer: resource를 요청한 모듈의 파일에 대한 절대 경로입니다. import하는 위치입니다.

**예:** `app.js` 내에서 `import './style.css'`를 수행할 때, resource는 `/path/to/style.css`이고 issuer는 `/path/to/app.js`입니다.

Rule의 [`test`](#ruletest), [`include`](#ruleinclude), [`exclude`](#ruleexclude) 그리고 [`resource`](#ruleresource) 프로퍼티가 resource와 일치하고 [`issuer`](#ruleissuer) 프로퍼티가 issuer와 일치합니다.

여러 조건을 사용하는 경우, 모든 조건이 일치해야 합니다.

W> 조심하세요! resource는 파일이 _해석된_ 경로이며, 이는 심볼릭 링크를 사용하는 resource가 심볼릭 링크의 위치가 _아닌_ 실제 경로임을 의미합니다. 이것은 `npm link`와 같은 패키지를 심볼릭 링크하는 도구를 사용할 때 기억하면 좋습니다. `/node_modules/`같은 일반적인 조건은 심볼릭 링크 된 파일을 실수로 놓칠 수 있습니다. resource가 심볼릭 링크 경로로 확인되도록 [`resolve.symlinks`](/configuration/resolve/#resolvesymlinks)를 통해 심볼릭 링크 해석을 끌 수 있습니다.

### Rule results

Rule results는 Rule condition이 일치하는 경우에만 사용됩니다.

Rule에는 두 가지 출력 값이 있습니다.

1. 적용된 로더: resource에 적용된 로더의 배열입니다.
2. 파서 옵션: 모듈에 대한 파서를 만드는 데 사용해야하는 옵션 객체입니다.

[`loader`](#ruleloader), [`options`](#ruleoptions--rulequery), [`use`](#ruleuse) 프로퍼티는 로더에 영향을 줍니다.

[`query`](#ruleoptions--rulequery), [`loaders`](#ruleloaders) 프로퍼티는 호환성을 위해 존재합니다.

[`enforce`](#ruleenforce) 프로퍼티는 일반, 사전 또는 사후 로더인지에 따라서 로더의 범주에 영향을 줍니다.

[`parser`](#ruleparser) 프로퍼티는 파서 옵션에 영향을 줍니다.

## Nested rules

중첩된 rules은 [`rules`](#rulerules), [`oneOf`](#ruleoneof) 프로퍼티에서 지정할 수 있습니다.

이러한 rule은 상위 Rule condition이 일치하는 경우에만 평가됩니다. 각 중첩 rule은 자체적으로 조건을 포함 할 수 있습니다.

평가의 순서는 다음과 같습니다.

1. 상위 rule
2. [`rules`](#rulerules)
3. [`oneOf`](#ruleoneof)

## Rule.enforce

`string`

가능한 값: `'pre' | 'post'`

로더의 범주를 지정합니다. 값이 없으면 일반 로더를 의미합니다.

추가적으로 import/require의 인라인으로 적용된 "인라인 로더"도 있습니다.

모든 로더가 차례로 통과하는 두 단계가 있습니다.

1. **Pitching** 단계: 로더의 pitch 메소드는 `post, inline, normal, pre` 순서로 호출됩니다. 자세한 내용은 [Pitching Loader](/api/loaders/#pitching-loader)를 참고하세요.
2. **Normal** 단계: 로더의 normal 메소드는 `pre, normal, inline, post` 순서로 호출됩니다. 모듈의 소스 코드에서 변환이 이 단계에서 발생합니다.

모든 일반 로더는 요청에 `!`를 접두사로 추가하여 생략(재정의) 할 수 있습니다.

모든 일반 및 사전 로더는 요청에 `-!`를 접두사로 추가하여 생략(재정의) 할 수 있습니다.

모든 일반, 사후 및 사전 로더는 요청에 `!!`를 접두사로 추가하여 생략(재정의) 할 수 있습니다.

```javascript
// 일반 로더 비활성화
import { a } from '!./file1.js';

// 사전, 일반 로더 비활성화
import { b } from '-!./file2.js';

// 모든 로더 비활성화
import { c } from '!!./file3.js';
```

인라인 로더와 `!` 접두사는 비표준이므로 사용해서는 안됩니다. 이것들은 로더가 생성한 코드에서 사용할 수 있습니다.

## Rule.exclude

조건과 일치하는 모든 모듈을 제외합니다. `Rule.exclude` 옵션을 사용하면 `Rule.resource` 옵션을 사용할 수 없습니다. 자세한 내용은 [`Rule.resource`](#ruleresource) 및 [`Condition.exclude`](#condition)를 참고하세요.

## Rule.include

조건과 일치하는 모든 모듈을 포함합니다. `Rule.include` 옵션을 사용하면 `Rule.resource` 옵션을 사용할 수 없습니다. 자세한 내용은 [`Rule.resource`](#ruleresource) 및 [`Condition.include`](#condition)를 참고하세요.

## Rule.issuer

요청한 모듈과 비교할 [`Condition`](#condition)입니다. 아래의 예제에서, `a.js`의 `issuer`는 `index.js` 파일의 경로입니다.

**index.js**

```javascript
import A from './a.js';
```

이 옵션은 특정 모듈 또는 모듈 세트의 디펜던시에 로더를 적용하는 데 사용할 수 있습니다.

## Rule.issuerLayer

issuer의 계층별로 필터링하고 일치시킬 수 있습니다.

**webpack.config.js**

```js
module.exports = {
  // ...
  module: {
    rules: [
      {
        issuerLayer: 'other-layer',
      },
    ],
  },
};
```

## Rule.layer

`string`

모듈이 배치되어야 하는 계층을 지정합니다.

**webpack.config.js**

```js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /module-layer-change/,
        layer: 'layer',
      },
    ],
  },
};
```

## Rule.loader

`Rule.loader`는 `Rule.use: [ { loader } ]`의 단축어입니다. 자세한 내용은 [`Rule.use`](#ruleuse)와 [`UseEntry.loader`](#useentry)를 참고하세요.

## Rule.loaders

W> 이 옵션은 `Rule.use`로 **대체되었습니다**.

`Rule.loaders`는 `Rule.use`의 별칭입니다. 자세한 내용은 [`Rule.use`](#ruleuse)를 참고하세요.

## Rule.mimetype

`mimetype`을 사용하여 설정 규칙을 데이터 URI에 일치시킬 수 있습니다.

**webpack.config.js**

```js
module.exports = {
  // ...
  module: {
    rules: [
      {
        mimetype: 'application/json',
        type: 'json',
      },
    ],
  },
};
```

`application/json`, `text/javascript`, `application/javascript`, `application/node` 및 `application/wasm`은 이미 기본적인 mimetype으로 포함되어 있습니다.

## Rule.oneOf

Rule이 일치할 때 첫 번째 일치하는 Rule만 사용되는 [`Rules`](#rule)의 배열입니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    rules: [
      {
        test: /\\.css$/,
        oneOf: [
          {
            resourceQuery: /inline/, // foo.css?inline
            use: 'url-loader',
          },
          {
            resourceQuery: /external/, // foo.css?external
            use: 'file-loader',
          },
        ],
      },
    ],
  },
};
```

T> 자세한 내용은 [`중첩된 rule`](#nested-rules)을 참고하세요.

## Rule.options / Rule.query

`Rule.options`과 `Rule.query`는 `Rule.use: [ { options } ]`의 단축어입니다. 자세한 내용은 [`Rule.use`](#ruleuse)와 [`UseEntry.options`](#useentry)을 참고하세요.

W> `Rule.query`는 `Rule.options`과 `UseEntry.options`으로 대체되었습니다.

## Rule.parser

파서 옵션이 있는 객체입니다. 적용된 모든 파서 옵션이 병합됩니다.

파서는 이러한 옵션을 검사하고 그에 따라 자체적으로 비활성화하거나 재구성할 수 있습니다. 대부분의 기본 플러그인은 값을 다음과 같이 해석합니다.

- 옵션을 `false`로 설정하면 파서가 비활성화됩니다.
- 옵션을 `true`로 설정하거나 `undefined`로 두면 파서가 활성화됩니다.

그러나, 파서 플러그인은 boolean 이상의 값을 받아들일 수 있습니다. 예를 들면, 내부의 `NodeStuffPlugin`은 `true` 대신에 객체를 받아 특정 Rule에 대한 옵션을 추가할 수 있습니다.

**예제** (기본 플러그인의 파서 옵션):

```js-with-links
module.exports = {
  //...
  module: {
    rules: [
      {
        //...
        parser: {
          amd: false, // AMD 비활성화
          commonjs: false, // CommonJS 비활성화
          system: false, // SystemJS 비활성화
          harmony: false, // ES2015 Harmony import/export 비활성화
          requireInclude: false, // require.include 비활성화
          requireEnsure: false, // require.ensure 비활성화
          requireContext: false, // require.context 비활성화
          browserify: false, // Browserify 번들의 특수 처리 비활성화
          requireJs: false, // requirejs.* 비활성화
          node: false, // __dirname, __filename, module, require.extensions, require.main, 등 비활성화
          commonjsMagicComments: false, // CommonJS를 위한 magic comments 지원 비활성화
          node: {...}, // 모듈 수준에서 [node](/configuration/node) 계층 재구성
          worker: ["default from web-worker", "..."] // javascript 파일에 대한 WebWorker 처리를 커스터마이즈합니다. "..."는 기본값을 나타냅니다.
        }
      }
    ]
  }
}
```

`Rule.type`이 `asset`이면 `Rules.parser` 옵션은 파일 내용을 Base64로 인코딩할지 또는 별도의 파일로 출력 디렉터리에 내보낼 지 여부를 나타내는 조건을 설명하는 객체 또는 함수일 수 있습니다.

`Rule.type`이 `asset` 또는 `asset/inline`인 경우 `Rule.generator`옵션은 모듈 소스의 인코딩을 설명하는 객체이거나 사용자 지정 알고리즘으로 모듈의 소스를 인코딩하는 함수일 수 있습니다.

추가적인 정보나 사용 사례를 위해 [애셋 모듈 가이드](/guides/asset-modules/)를 참고하세요.

## Rule.parser.dataUrlCondition

`object = { maxSize number = 8096 }` `function (source, { filename, module }) => boolean`

모듈 소스 크기가 `maxSize`보다 작으면 모듈이 Base64 인코딩 문자열로 번들에 삽입되고, 그렇지 않으면 모듈 파일이 출력 디렉터리로 내보내집니다.

**webpack.config.js**

```js
module.exports = {
  //...
  module: {
    rules: [
      {
        //...
        parser: {
          dataUrlCondition: {
            maxSize: 4 * 1024,
          },
        },
      },
    ],
  },
};
```

함수를 dataUrlCondition의 값으로 설정한 경우에는 `true`를 반환하면 webpack이 모듈을 Base64 인코딩 문자열로 번들에 삽입하도록 지시합니다. 그렇지 않으면 모듈 파일이 출력 디렉토리로 내보내집니다.

**webpack.config.js**

```js
module.exports = {
  //...
  module: {
    rules: [
      {
        //...
        parser: {
          dataUrlCondition: (source, { filename, module }) => {
            const content = source.toString();
            return content.includes('some marker');
          },
        },
      },
    ],
  },
};
```

## Rule.generator

### Rule.generator.dataUrl

`object = { encoding string = 'base64' | false, mimetype string = undefined | false }` `function (content, { filename, module }) => string`

`Rule.generator.dataUrl`이 객체로 사용되면 두개의 프로퍼티를 설정할 수 있습니다.

- encoding: `'base64'`로 설정하면 모듈 소스는 Base64 알고리즘을 사용하여 인코딩됩니다. `encoding`을 false로 설정하면 인코딩이 비활성화됩니다.
- mimetype: 데이터 URI의 MIME 유형입니다. 기본적으로 모듈 리소스 확장에서 확인합니다.

**webpack.config.js**

```js
module.exports = {
  //...
  module: {
    rules: [
      {
        //...
        generator: {
          dataUrl: {
            encoding: 'base64',
            mimetype: 'mimetype/png',
          },
        },
      },
    ],
  },
};
```

함수로 사용하면 모든 모듈에 대해 실행되며 데이터 URI 문자열을 반환해야 합니다.

```js
module.exports = {
  //...
  module: {
    rules: [
      {
        //...
        generator: {
          dataUrl: (content) => {
            const svgToMiniDataURI = require('mini-svg-data-uri');
            if (typeof content !== 'string') {
              content = content.toString();
            }
            return svgToMiniDataURI(content);
          },
        },
      },
    ],
  },
};
```

### Rule.generator.emit

[애셋 모듈](/guides/asset-modules/)에서 애셋 쓰기를 하지 않는 경우, 서버 사이드 랜더링에서 사용할 수 있습니다.

- Type: `boolean = true`
- Available: <Badge text='5.25.0+' />
- Example:

  ```js
  module.exports = {
    // …
    module: {
      rules: [
        {
          test: /\.png$/i,
          type: 'asset/resource',
          generator: {
            emit: false,
          },
        },
      ],
    },
  };
  ```

### Rule.generator.filename

[`output.assetModuleFilename`](/configuration/output/#outputassetmodulefilename)과 동일하지만 특정 규칙에 사용됩니다. `output.assetModuleFilename`을 재정의하고 `asset` 및 `asset/resource` 모듈 유형에서만 작동합니다.

**webpack.config.js**

```js
module.exports = {
  //...
  output: {
    assetModuleFilename: 'images/[hash][ext][query]',
  },
  module: {
    rules: [
      {
        test: /\.png/,
        type: 'asset/resource',
      },
      {
        test: /\.html/,
        type: 'asset/resource',
        generator: {
          filename: 'static/[hash][ext]',
        },
      },
    ],
  },
};
```

### Rule.generator.publicPath

특정 애셋 모듈에 대해 `publicPath`를 사용자 지정합니다.

- Type: `string | ((pathData: PathData, assetInfo?: AssetInfo) => string)`
- Available: <Badge text='5.28.0+' />

```js
module.exports = {
  //...
  output: {
    publicPath: 'static/',
  },
  module: {
    rules: [
      {
        test: /\.png$/i,
        type: 'asset/resource',
        generator: {
          publicPath: 'assets/',
        },
      },
    ],
  },
};
```

## Rule.resource

리소스와 일치하는 [`Condition`](#condition)입니다. 자세한 내용은 [`규칙` 조건](#rule-conditions)을 참고하세요.

## Rule.resourceQuery

리소스 쿼리와 일치하는 [`Condition`](#condition)입니다. 이 옵션은 요청 문자열의 쿼리 섹션에 대해 테스트하는 경우 사용됩니다(즉, 물음표부터). `import Foo from './foo.css?inline'`을 사용하는 경우 다음 조건이 일치합니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    rules: [
      {
        test: /\\.css$/,
        resourceQuery: /inline/,
        use: 'url-loader',
      },
    ],
  },
};
```

## Rule.parser.parse

`function(input) => string | object`

`Rule.type`이 `'json'`으로 설정된 경우 `Rules.parser.parse`옵션은 모듈의 소스를 구문 분석하고 이를 JavaScript `객체`로 변환하는 커스텀 로직을 구현하는 함수일 수 있습니다. 특정 로더없이 `toml`, `yaml` 및 기타 JSON이 아닌 파일을 JSON으로 가져 오는 것이 유용할 수 있습니다.

**webpack.config.js**

```javascript
const toml = require('toml');

module.exports = {
  //...
  module: {
    rules: [
      {
        test: /\.toml/,
        type: 'json',
        parser: {
          parse: toml.parse,
        },
      },
    ],
  },
};
```

## Rule.rules

Rule이 일치 할 때도 사용되는 [`Rules`](#rule)의 배열입니다.

T> 자세한 정보는 [`중첩된 rules`](#nested-rules)를 참고하세요.

## Rule.sideEffects

`bool`

모듈의 어떤 부분에 부작용이 있는지 표시하세요. 자세한 내용은 [Tree Shaking](/guides/tree-shaking/#mark-the-file-as-side-effect-free)을 참고하세요.

## Rule.test

테스트를 통과하는 모든 모듈을 포함합니다. `Rule.test` 옵션을 제공하면 `Rule.resource`도 제공 할 수 없습니다. 자세한 내용은 [`Rule.resource`](#ruleresource) 및 [`Condition.test`](#condition)를 참고하세요.

## Rule.type

`string`

가능한 변수: `'javascript/auto' | 'javascript/dynamic' | 'javascript/esm' | 'json' | 'webassembly/sync' | 'webassembly/async' | 'asset' | 'asset/source' | 'asset/resource' | 'asset/inline'`

`Rule.type`은 일치하는 모듈의 유형을 설정합니다. 이는 defaultRules 및 기본값 import 동작이 발생하지 않습니다. 예를 들어 커스텀 로더를 통해 `.json`파일을 로드하려면 `type`을 `javascript/auto`로 설정하여 webpack에 내장된 json import를 우회해야합니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    rules: [
      //...
      {
        test: /\\.json$/,
        type: 'javascript/auto',
        loader: 'custom-json-loader',
      },
    ],
  },
};
```

> `asset*` 유형에 대한 자세한 내용은 [애셋 모듈 가이드](/guides/asset-modules/)를 참고하세요.

## Rule.use

`[UseEntry]` `function(info)`

**`[UseEntry]`**

`Rule.use`는 모듈에 적용되는 [UseEntry](#useentry)의 배열일 수 있습니다.

`use: [ 'style-loader' ]` 같이 string을 전달하는 것은 `use: [ { loader: 'style-loader '} ]` 같이 loader 프로퍼티에 대한 단축어 입니다.

로더는 여러 로더를 전달하여 연결될 수 있으며, 이는 오른쪽에서 왼쪽으로, 마지막 설정에서 첫 번째 설정 순서로 적용됩니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    rules: [
      {
        //...
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              importLoaders: 1,
            },
          },
          {
            loader: 'less-loader',
            options: {
              noIeCompat: true,
            },
          },
        ],
      },
    ],
  },
};
```

**`function(info)`**

`Rule.use`는 로드 중인 모듈을 설명하는 객체를 인수로 받는 함수일 수도 있으며 `UseEntry`를 원소로 가지는 배열을 반환해야 합니다.

`info` 객체 파라미터는 다음과 같은 필드를 가집니다.

- `compiler`: 현재 webpack 컴파일러 (정의되지 않을 수 있음)
- `issuer`: 로드 중인 모듈을 가져오는 모듈의 경로
- `realResource`: 항상 로드되는 모듈의 경로
- `resource`: 로드되는 모듈의 경로. 요청 문자열의 `!=!`를 통해 리소스 이름을 덮어 쓰는 경우를 제외하고는 일반적으로 `realResource`와 같습니다.

반환값에 `use: [ 'style-loader' ]`같이 배열과 동일한 단축어를 사용할 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    rules: [
      {
        use: (info) => [
          {
            loader: 'custom-svg-loader',
          },
          {
            loader: 'svgo-loader',
            options: {
              plugins: [
                {
                  cleanupIDs: {
                    prefix: basename(info.resource),
                  },
                },
              ],
            },
          },
        ],
      },
    ],
  },
};
```

자세한 정보는 [UseEntry](#useentry)를 참고하세요.

## Rule.resolve

W> `Rule.resolve`는 webpack 4.36.1 이후로 사용 가능합니다.

모듈 계층에서 해석에 대한 설정을 할 수 있습니다. [해설 설정 페이지](/configuration/resolve/#resolve)에서 가능한 모든 옵션을 참고하세요.
적용된 모든 해석 옵션은 상위 계층의 해석 옵션과 병합됩니다.

예를 들면, 모듈 계층 해석을 보여주기 위해 `./src/index.js`, `./src/footer/default.js` 및 `./src/footer/overridden.js` 엔트리가 있다고 가정하겠습니다.

**./src/index.js**

```javascript
import footer from 'footer';
console.log(footer);
```

**./src/footer/default.js**

```javascript
export default 'default footer';
```

**./src/footer/overridden.js**

```javascript
export default 'overridden footer';
```

**webpack.js.org**

```javascript
module.exports = {
  resolve: {
    alias: {
      footer: './footer/default.js',
    },
  },
};
```

이 설정으로 번들을 생성하면 `console.log(footer)`는 'default footer'를 출력합니다. `.js`파일에 대한 `Rule.resolve`를 설정하고 `footer` 별칭을 `overridden.js`로 설정해보겠습니다.

**webpack.js.org**

```javascript
module.exports = {
  resolve: {
    alias: {
      footer: './footer/default.js',
    },
  },
  module: {
    rules: [
      {
        resolve: {
          alias: {
            footer: './footer/overridden.js',
          },
        },
      },
    ],
  },
};
```

변경된 설정으로 번들을 생성하면 `console.log(footer)`는 'overridden footer'를 출력합니다.

### resolve.fullySpecified

`boolean = true`

활성화되면 `.mjs` 파일 또는 다른 `.js` 파일에서 모듈을 `import`할 때 가장 가까운 상위 `package.json`파일에 `"type"`필드가 `"module"`을 값으로 가지고 있는 경우 파일 확장자를 제공해야합니다. 그렇지 않으면 webpack이 `Module not found` 오류와 함께 컴파일에 실패합니다. 그리고 webpack은 [`resolve.mainFiles`](/configuration/resolve/#resolvemainfiles)에 정의된 파일 이름으로 디렉터리를 확인하지 않으므로 파일 이름을 직접 지정해야합니다.

**webpack.config.js**

```js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.m?js$/,
        resolve: {
          fullySpecified: false, // 비활성화
        },
      },
    ],
  },
};
```

W> `resolve.fullySpecified`는 [mainFields](/configuration/resolve/#resolvemainfields), [aliasFields](/configuration/resolve/#resolvealiasfields) 또는 [aliases](/configuration/resolve/#resolvealias)의 요청에 영향을 주지 않습니다.

## Condition

Condition은 아래 항목중의 하나가 됩니다.

- 문자열: 입력을 일치시키려면 제공된 문자열로 시작해야 합니다. 예를 들면, 절대 디렉토리 경로 또는 파일의 절대 경로입니다.
- 정규표현식: 입력을 검사합니다.
- 함수: 입력과 함께 호출되며 일치하려면 참과 같은 값을 반환해야 합니다.
- Condition 배열: Condition 중 하나 이상이 일치해야 합니다.
- 객체: 모든 프로퍼티가 일치해야 합니다. 각 속성에는 정의 된 동작이 있습니다.

`{ and: [Condition] }`: 모든 Condition이 일치해야 합니다.

`{ or: [Condition] }`: 어떤 Condition이든 일치하면 됩니다.

`{ not: [Condition] }`: 모든 Condition이 일치하면 안 됩니다.

**Example:**

```javascript
const path = require('path');

module.exports = {
  //...
  module: {
    rules: [
      {
        test: /\\.css$/,
        include: [
          // `app/styles`로 시작하는 현재 디렉터리와 관련된 모든 경로를 포함합니다.
          // 예. `app/styles.css`, `app/styles/styles.css`, `app/stylesheet.css`
          path.resolve(__dirname, 'app/styles'),
          // `vendor/styles/` 디렉터리의 내용만 포함하도록 슬래시를 추가합니다.
          path.join(__dirname, 'vendor/styles/'),
        ],
      },
    ],
  },
};
```

## UseEntry

`object` `function(info)`

**`object`**

문자열인 `loader` 프로퍼티가 있어야 합니다. 로더 해석 옵션([resolveLoader](/configuration/resolve/#resolveloader))을 사용하여 설정 [`context`](/configuration/entry-context/#context)에 상대적으로 해석됩니다.

`options` 프로퍼티는 문자열이나 객체가 될 수 있습니다. 이 값은 로더에 전달되며 로더 옵션으로 해석되어야 합니다.

호환성을 위해 `options` 프로퍼티의 별칭인 `query` 속성도 가능합니다. `options` 프로퍼티를 사용하는 것을 권장합니다.

webpack은 옵션을 포함한 모든 로더와 리소스에서 고유한 모듈 식별자를 생성해야합니다. 옵션 객체의 `JSON.stringify`로 이를 시도합니다. 99.9%의 경우에 문제가 없지만 리소스에 다른 옵션이 있는 동일한 로더를 적용하고 옵션에 일부 문자열 값이 있는 경우 고유하지 않을 수 있습니다.

순환 JSON 같은 옵션 객체를 문자열화 할 수 없는 경우에도 중단됩니다. 이를 해결하기 위해 고유 식별자로 사용되는 옵션 객체에서 `ident` 속성을 가질 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    rules: [
      {
        loader: 'css-loader',
        options: {
          modules: true,
        },
      },
    ],
  },
};
```

**`function(info)`**

`UseEntry`는 로드되는 모듈을 나타내는 객체를 인수로 받는 함수일 수도 있으며 함수가 아닌 `UseEntry` 객체를 반환해야 합니다.

`info` 객체 파라미터에는 다음과 같은 필드가 있습니다.

- `compiler`: 현재 webpack 컴파일러 (정의되지 않을 수 있음)
- `issuer`: 로드 중인 모듈을 가져오는 모듈의 경로
- `realResource`: 항상 로드되는 모듈의 경로
- `resource`: 로드되는 모듈의 경로. 요청 문자열의 `!=!`를 통해 리소스 이름을 덮어 쓰는 경우를 제외하고는 일반적으로 `realResource`와 같습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    rules: [
      {
        loader: 'file-loader',
        options: {
          outputPath: 'svgs',
        },
      },
      (info) => ({
        loader: 'svgo-loader',
        options: {
          plugins: [
            {
              cleanupIDs: { prefix: basename(info.resource) },
            },
          ],
        },
      }),
    ],
  },
};
```

## Module Contexts

이 옵션은 동적 종속성이 발생할 때 생성되는 컨텍스트의 기본 설정을 설명합니다.

`unknown` 동적 종속성 의 예시: `require`.

`expr` 동적 종속성 의 예시: `require(expr)`.

`wrapped` 동적 종속성 의 예시: `require('./templates/' + expr)`.

다음은 [기본값](https://github.com/webpack/webpack/blob/master/lib/config/defaults.js)으로 사용 가능한 옵션입니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  module: {
    exprContextCritical: true,
    exprContextRecursive: true,
    exprContextRegExp: false,
    exprContextRequest: '.',
    unknownContextCritical: true,
    unknownContextRecursive: true,
    unknownContextRegExp: false,
    unknownContextRequest: '.',
    wrappedContextCritical: false,
    wrappedContextRecursive: true,
    wrappedContextRegExp: /.*/,
    strictExportPresence: false, // webpack 2.3.0 이후부터
  },
};
```

T> `ContextReplacementPlugin`을 사용하여 개별 종속성에 대한 값을 수정할 수 있습니다. 이것은 또한 경고를 제거합니다.

다음은 몇 가지 사용 사례입니다.

- 동적 종속성에 대한 경고(`wrappedContextCritical: true`)
- `require(expr)`는 전체 디렉터리를 포함해야합니다(`exprContextRegExp: /^\\.\\//`).
- `require('./templates/'+ expr)`은 기본적으로 하위 디렉터리를 포함하지 않아야 합니다(`wrappedContextRecursive : false`).
- `strictExportPresence`는 export가 누락되면 경고 대신 오류를 발생시킵니다.
- 부분적 동적 종속성에 대한 내부 정규식 설정(`wrappedContextRegExp: /\\.\\*/`)
