---
title: Output
sort: 6
contributors:
  - sokra
  - skipjack
  - tomasAlabes
  - mattce
  - irth
  - fvgs
  - dhurlburtusa
  - MagicDuck
  - fadysamirsadek
  - byzyk
  - madhavarshney
  - harshwardhansingh
  - eemeli
  - EugeneHlushko
  - g-plane
  - smelukov
  - Neob91
  - anikethsaha
  - jamesgeorge007
  - hiroppy
  - chenxsan
  - snitin315
  - QC-L
  - anshumanv
  - mrzalyaul
translators:
  - YukJiSoo
---

최상위 `output` 키에는 번들, 애셋 및 webpack으로 번들링하거나 로드하는 기타 항목을 출력하는 방법과 위치를 webpack에 지시하는 옵션이 포함되어 있습니다.

## output.assetModuleFilename

`string = '[hash][ext][query]'`

[`output.filename`](#outputfilename)과 동일하지만 [애셋 모듈](/guides/asset-modules/)용입니다.

## output.auxiliaryComment

W> [`output.library.auxiliaryComment`](#outputlibraryauxiliarycomment)를 사용하는 것이 좋습니다.

`string` `object`

[`output.library`](#outputlibrary) 및 [`output.libraryTarget`](#outputlibrarytarget)과 함께 사용되는 경우, 사용자가 export 래퍼 내에 주석을 삽입할 수 있습니다. 각 `libraryTarget` 타입에 동일한 주석을 삽입하려면 `auxiliaryComment`를 문자열로 설정하세요.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    library: 'someLibName',
    libraryTarget: 'umd',
    filename: 'someLibName.js',
    auxiliaryComment: 'Test Comment',
  },
};
```

그러면 다음과 같이 생성됩니다.

**someLibName.js**

```javascript
(function webpackUniversalModuleDefinition(root, factory) {
  // Test Comment
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory(require('lodash'));
  // Test Comment
  else if (typeof define === 'function' && define.amd)
    define(['lodash'], factory);
  // Test Comment
  else if (typeof exports === 'object')
    exports['someLibName'] = factory(require('lodash'));
  // Test Comment
  else root['someLibName'] = factory(root['_']);
})(this, function (__WEBPACK_EXTERNAL_MODULE_1__) {
  // ...
});
```

각 `libraryTarget` 주석을 세밀하게 제어하려면 객체로 설정하세요.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    //...
    auxiliaryComment: {
      root: 'Root Comment',
      commonjs: 'CommonJS Comment',
      commonjs2: 'CommonJS2 Comment',
      amd: 'AMD Comment',
    },
  },
};
```

## `output.charset`

`boolean = true`

webpack이 HTML의 `<script>` 태그에 `charset="utf-8"`을 추가하도록 합니다.

T> `<script>`태그의 `charset`속성이 [지원 중단](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#Deprecated_attributes)된 상태지만 최신이 아닌 브라우저와의 호환성을 위해 webpack은 여전히 charset을 기본적으로 추가합니다.

## `output.chunkFilename`

`string = '[id].js'` `function (pathData, assetInfo) => string`

이 옵션은 초기가 아닌 청크 파일의 이름을 결정합니다. 가능한 값에 대한 자세한 내용은 [`output.filename`](#outputfilename) 옵션을 참고하세요.

청크 파일 요청을 위해 런타임에서 파일 이름을 생성해야 합니다. 이 때문에 `[name]` 및 `[chunkhash]`와 같은 자리 표시자는 webpack 런타임을 사용하여 청크 ID에서 자리 표시자 값으로의 매핑을 출력 번들에 추가해야 합니다. 이렇게하면 크기가 증가하고 청크의 자리 표시자 값이 변경 될 때 번들이 무효화 될 수 있습니다.

기본적으로 `[id].js`가 사용되거나 [`output.filename`](#outputfilename)에서 유추 된 값이 사용됩니다(`[name]`이 `[id]`로 대체되거나 `[id].`가 추가).

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    //...
    chunkFilename: '[id].js',
  },
};
```

함수로 사용할 수도 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    chunkFilename: (pathData) => {
      return pathData.chunk.name === 'main' ? '[name].js' : '[name]/[name].js';
    },
  },
};
```

## output.chunkFormat

`false` `string: 'array-push' | 'commonjs' | 'module' | <any string>`

청크의 포맷 (기본적으로 포함되는 포맷은 `'array-push'` (web/WebWorker), `'commonjs'` (node.js), `'module'` (ESM) 등이지만 플러그인에 의해 추가될 수 있습니다).

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    //...
    chunkFormat: 'commonjs',
  },
};
```

## `output.chunkLoadTimeout`

`number = 120000`

청크 요청이 만료되기까지의 밀리 초 단위의 시간입니다. 이 옵션은 webpack 2.6.0부터 지원됩니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    //...
    chunkLoadTimeout: 30000,
  },
};
```

## `output.chunkLoadingGlobal`

`string = 'webpackChunkwebpack'`

webpack에서 청크를 로드하기 위해 사용하는 전역 변수입니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    //...
    chunkLoadingGlobal: 'myCustomFunc',
  },
};
```

## output.chunkLoading

`false` `string: 'jsonp' | 'import-scripts' | 'require' | 'async-node' | 'import' | <any string>`

청크를 로드하는 메소드.(기본적으로 포함된 메소드는 `'jsonp'` (web), `'import'` (ESM), `'importScripts'` (WebWorker), `'require'` (sync node.js), `'async-node'` (async node.js) 등이지만 플러그인에 의해 추가될 수 있습니다).

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    //...
    chunkLoading: 'async-node',
  },
};
```

## output.clean

<Badge text="5.20.0+" />

`boolean` `{ dry?: boolean, keep?: RegExp | string | ((filename: string) => boolean) }`

```javascript
module.exports = {
  //...
  output: {
    clean: true, // 내보내기 전에 output 디렉토리를 정리합니다.
  },
};
```

```javascript
module.exports = {
  //...
  output: {
    clean: {
      dry: true, // 삭제하는 대신 제거해야 하는 애셋을 기록합니다.
    },
  },
};
```

```javascript
module.exports = {
  //...
  output: {
    clean: {
      keep: /ignored\/dir\//, // 애셋을 'ignored/dir' 아래에 유지합니다.
    },
  },
};

// 또는

module.exports = {
  //...
  output: {
    clean: {
      keep(asset) {
        return asset.includes('ignored/dir');
      },
    },
  },
};
```

hook과 함께 사용할 수도 있습니다.

```javascript
webpack.CleanPlugin.getCompilationHooks(compilation).keep.tap(
  'Test',
  (asset) => {
    if (/ignored\/dir\//.test(asset)) return true;
  }
);
```

## `output.compareBeforeEmit`

`boolean = true`

출력 파일 시스템에 쓰기 전에 내보낼 파일이 이미 존재하고 동일한 내용이 있는지 확인하도록 webpack에 지시합니다.

W> 동일한 내용의 파일이 디스크에 이미 있는 경우 webpack은 출력 파일을 만들지 않습니다.

```javascript
module.exports = {
  //...
  output: {
    compareBeforeEmit: false,
  },
};
```

## output.crossOriginLoading

`boolean = false` `string: 'anonymous' | 'use-credentials'`

청크의 [cross-origin](https://developer.mozilla.org/en/docs/Web/HTML/Element/script#attr-crossorigin) 로드를 활성화하도록 webpack에게 전달합니다. script 태그를 추가하여 온 디맨트 청크를 로드할 때 JSONP를 사용하는 `'web'`으로 [`target`](/configuration/target/)이 설정된 경우에만 적용됩니다.

- `'anonymous'` - **자격 증명 없이** cross-origin 활성화
- `'use-credentials'` - **자격 증명과 함께** cross-origin 활성화

## `output.devtoolFallbackModuleFilenameTemplate`

`string` `function (info)`

위의 템플릿 문자열 또는 함수가 중복을 생성할 때 사용되는 폴백입니다.

[`output.devtoolModuleFilenameTemplate`](#outputdevtoolmodulefilenametemplate)을 참고하세요.

## `output.devtoolModuleFilenameTemplate`

`string = 'webpack://[namespace]/[resource-path]?[loaders]'` `function (info) => string`

이 옵션은 [`devtool`](/configuration/devtool)이 모듈 이름이 필요한 옵션을 사용하는 경우에만 사용됩니다.

각 소스맵의 `sources`배열에 사용되는 이름을 사용자 정의합니다. 이는 템플릿 문자열 또는 함수를 전달하여 수행할 수 있습니다. 예를 들어 `devtool: 'eval'`을 사용하는 경우입니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    devtoolModuleFilenameTemplate:
      'webpack://[namespace]/[resource-path]?[loaders]',
  },
};
```

아래의 substitution 항목은 webpack의 내부 [`ModuleFilenameHelpers`](https://github.com/webpack/webpack/blob/master/lib/ModuleFilenameHelpers.js)를 통해 템플릿 문자열에서 사용할 수 있습니다.

| Template                 | Description                                                                                             |
| ------------------------ | ------------------------------------------------------------------------------------------------------- |
| [absolute-resource-path] | 절대 경로 파일이름                                                                                      |
| [all-loaders]            | 자동 및 명시적 로더, 첫 번째 로더 이름까지 파라미터                                                     |
| [hash]                   | 모듈 식별자의 해시                                                                                      |
| [id]                     | 모듈 식별자                                                                                             |
| [loaders]                | 명시적 로더, 첫 번째 로더 이름까지 파라미터                                                             |
| [resource]               | 파일을 확인하는 데 사용되는 경로와 첫 번째 로더에서 사용되는 쿼리 파라미터                              |
| [resource-path]          | 쿼리 파라미터없이 파일을 해결하는 경우 사용되는 경로                                                    |
| [namespace]              | 모듈 네임스페이스. 일반적으로 라이브러리로 빌드할 때 라이브러리의 이름이고 라이브러리가 아니면 비어있음 |

함수를 사용할 때 `info` 파라미터를 통해 동일한 옵션을 camel case로 사용할 수 있습니다.

```javascript
module.exports = {
  //...
  output: {
    devtoolModuleFilenameTemplate: (info) => {
      return `webpack:///${info.resourcePath}?${info.loaders}`;
    },
  },
};
```

여러 모듈의 이름이 동일한 경우 [`output.devtoolFallbackModuleFilenameTemplate`](#outputdevtoolfallbackmodulefilenametemplate)이 대신 사용됩니다.

## `output.devtoolNamespace`

`string`

이 옵션은 [`output.devtoolModuleFilenameTemplate`](#outputdevtoolmodulefilenametemplate)과 함께 사용되는 모듈 네임스페이스를 결정합니다. 지정되지 않은 경우 기본값은 [`output.library`](#outputlibrary)입니다. webpack으로 빌드된 여러 라이브러리를 로드할 때 소스맵에서 소스 파일 경로 충돌을 방지하는 경우 사용됩니다.

예를 들어, 네임스페이스가 `library1`과 `library2`인 라이브러리가 2개 있고 둘 다 `./src/index.js`파일(잠재적으로 다른 내용 포함)이 있는 경우 이 파일은 `webpack://library1/./src/index.js`, `webpack://library2/./src/index.js`로 내보내집니다.

## output.enabledChunkLoadingTypes

`[string: 'jsonp' | 'import-scripts' | 'require' | 'async-node' | <any string>]`

엔트리포인트에서 사용할 수 있는 청크 로드의 유형 목록입니다. webpack에 의해 자동으로 채워집니다. 함수를 입력 옵션으로 사용하고, 거기에서 chunkLoading 옵션을 반환할 때만 필요합니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    //...
    enabledChunkLoadingTypes: ['jsonp', 'require'],
  },
};
```

## output.enabledLibraryTypes

`[string]`

엔트리 포인트에서 사용할 수 있는 라이브러리 타입 목록입니다.

```javascript
module.exports = {
  //...
  output: {
    enabledLibraryTypes: ['module'],
  },
};
```

## output.enabledWasmLoadingTypes

`[string]`

엔트리 포인트에서 사용할 수 있는 wasm 로딩 유형 목록입니다.

```javascript
module.exports = {
  //...
  output: {
    enabledWasmLoadingTypes: ['fetch'],
  },
};
```

## output.environment

생성된 런타임 코드에서 어떤 종류의 ES 기능을 사용할 수 있는지 webpack에 알려줍니다.

```javascript
module.exports = {
  output: {
    environment: {
      // The environment supports arrow functions ('() => { ... }').
      arrowFunction: true,
      // The environment supports BigInt as literal (123n).
      bigIntLiteral: false,
      // The environment supports const and let for variable declarations.
      const: true,
      // The environment supports destructuring ('{ a, b } = obj').
      destructuring: true,
      // The environment supports an async import() function to import EcmaScript modules.
      dynamicImport: false,
      // The environment supports 'for of' iteration ('for (const x of array) { ... }').
      forOf: true,
      // The environment supports ECMAScript Module syntax to import ECMAScript modules (import ... from '...').
      module: false,
    },
  },
};
```

## `output.filename`

`string` `function (pathData, assetInfo) => string`

이 옵션은 각 출력 번들의 이름을 결정합니다. 번들은 [`output.path`](#outputpath) 옵션으로 지정된 디렉터리에 작성됩니다.

단일 [`entry`](/configuration/entry-context/#entry) 지점의 경우 정적인 이름으로 설정할 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    filename: 'bundle.js',
  },
};
```

그러나 둘 이상의 엔트리 포인트, 코드 분할 또는 다양한 플러그인을 통해 여러 번들을 생성할 때 다음 substitution 중 하나를 사용하여 각 번들에 고유한 이름을 부여해야 합니다.

엔트리 이름을 사용할 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    filename: '[name].bundle.js',
  },
};
```

내부 청크 id를 사용할 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    filename: '[id].bundle.js',
  },
};
```

생성된 콘텐츠에서 생성된 해시를 사용할 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    filename: '[contenthash].bundle.js',
  },
};
```

여러 substitution을 조합할 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    filename: '[name].[contenthash].bundle.js',
  },
};
```

파일 이름을 반환하는 함수를 사용할 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    filename: (pathData) => {
      return pathData.chunk.name === 'main' ? '[name].js' : '[name]/[name].js';
    },
  },
};
```

자세한 내용은 [캐싱 가이드](/guides/caching)를 참고하세요. 이 옵션을 설정하는 것보다 더 많은 단계를 필요로 합니다.

이 옵션의 이름은 filename 이지만 `'js/[name]/bundle.js'`와 같이 폴더 구조의 이름을 사용할 수 있습니다.

이 옵션은 온 디맨드 로드되는 청크의 출력 파일에는 영향을 주지 않습니다. 처음에 로드된 출력 파일에만 영향을 줍니다. 온 디맨드 로드 된 청크 파일의 경우 [`output.chunkFilename`](#outputchunkfilename) 옵션이 사용됩니다. 로더에서 생성된 파일도 영향을 받지 않습니다. 이 경우 특정 로더에서 사용 가능한 옵션의 사용을 시도해봐야 합니다.

## Template strings

다음 substitution은 webpack의 내부 [`TemplatedPathPlugin`](https://github.com/webpack/webpack/blob/master/lib/TemplatedPathPlugin.js)를 통해 템플릿 문자열에서 사용할 수 있습니다.

컴파일 수준에서 사용할 수 있는 substitution입니다.

| Template   | Description           |
| ---------- | --------------------- |
| [fullhash] | 컴파일 전체 해시      |
| [hash]     | 더 이상 지원되지 않음 |

청크 수준에서 사용할 수 있는 substitution입니다.

| Template      | Description                                                                              |
| ------------- | ---------------------------------------------------------------------------------------- |
| [id]          | 청크의 identifier                                                                        |
| [name]        | 청크의 이름, 설정되지 않은 경우 청크의 ID                                                |
| [chunkhash]   | 청크의 모든 요소를 포함한 청크의 해시                                                    |
| [contenthash] | 콘텐츠 타입의 요소만 포함하는 청크의 해시 (`optimization.realContentHash`의 영향을 받음) |

모듈 수준에서 사용할 수 있는 substitution입니다.

| Template      | Description           |
| ------------- | --------------------- |
| [id]          | 모듈의 id             |
| [moduleid]    | 더 이상 지원되지 않음 |
| [hash]        | 모듈의 해시           |
| [modulehash]  | 더 이상 지원되지 않음 |
| [contenthash] | 모듈 콘텐츠의 해시    |

파일 수준에서 사용할 수 있는 substitution입니다.

| Template   | Description                                 |
| ---------- | ------------------------------------------- |
| [file]     | 쿼리 또는 fragment가 없는 파일 이름 및 경로 |
| [query]    | 앞에 `?`가 있는 쿼리                        |
| [fragment] | 앞에 `#`가 있는 fragment                    |
| [base]     | 경로없이 확장자를 포함한 파일 이름          |
| [filebase] | 더 이상 지원되지 않음                       |
| [path]     | 파일 이름을 제외한 경로                     |
| [name]     | 확장자나 경로가 없는 파일 이름              |
| [ext]      | `.`으로 시작하는 확장자                     |

URL 수준에서 사용할 수 있는 substitution입니다.

| Template | Description |
| -------- | ----------- |
| [url]    | URL         |

T> `[file]`은 `[path][base]`와 같습니다. `[base]`는 `[name][ext]`와 같습니다. 전체 경로는 `[path][name][ext][query][fragment]` 또는 `[path][base][query][fragment]` 또는 `[file][query][fragment]`입니다.

해시 길이(`[hash]`, `[contenthash]` 또는 `[chunkhash]`)는 `[hash:16]`(기본값 20)을 사용하여 지정할 수 있습니다. 또는 [`output.hashDigestLength`](#outputhashdigestlength)를 지정하여 길이를 전역적으로 설정합니다.

실제 파일 이름에 자리 표시자 중 하나를 사용하려는 경우 자리 표시자를 필터링 할 수 있습니다. 예를 들어 `[name].js` 파일을 출력하려면 대괄호 사이에 백 슬래시를 추가하여 `[name]` 자리 표시자를 이스케이프해야합니다. 따라서 `[\name\]`은 애셋의 `name`으로 대체되는 대신 `[name]`을 생성합니다.

예제: `[\id\]`는 `id`로 교체되지 않고 `[id]`를 생성합니다.

이 옵션에 대한 함수를 사용하는 경우 함수는 위 표의 substitution 데이터를 포함하는 객체로 전달됩니다.
반환된 문자열에도 substitution이 적용됩니다.
전달 된 객체의 타입은 다음과 같습니다. 프로퍼티는 컨텍스트에 따라 사용 가능합니다.

```typescript
type PathData = {
  hash: string;
  hashWithLength: (number) => string;
  chunk: Chunk | ChunkPathData;
  module: Module | ModulePathData;
  contentHashType: string;
  contentHash: string;
  contentHashWithLength: (number) => string;
  filename: string;
  url: string;
  runtime: string | SortableSet<string>;
  chunkGraph: ChunkGraph;
};
type ChunkPathData = {
  id: string | number;
  name: string;
  hash: string;
  hashWithLength: (number) => string;
  contentHash: Record<string, string>;
  contentHashWithLength: Record<string, (number) => string>;
};
type ModulePathData = {
  id: string | number;
  hash: string;
  hashWithLength: (number) => string;
};
```

T> 일부 컨텍스트에서 프로퍼티는 원시 값 대신 JavaScript 코드 표현식을 사용합니다. 이러한 경우 `WithLength`변형을 사용할 수 있으며 원래 값을 분할하는 대신 사용해야합니다.

## `output.globalObject`

`string = 'window'`

라이브러리를 대상으로 할 때, 특히 `libraryTarget`이 `'umd'`인 경우 이 옵션은 라이브러리를 마운트하는 데 사용할 전역 객체를 나타냅니다. UMD빌드를 브라우저와 Node.js에서 모두 사용할 수 있도록 하려면 `output.globalObject`를 `'this'`로 설정하세요. 웹과 유사한 대상의 경우 기본값은 `self`입니다.

예제:

**webpack.config.js**

```javascript
module.exports = {
  // ...
  output: {
    library: 'myLib',
    libraryTarget: 'umd',
    filename: 'myLib.js',
    globalObject: 'this',
  },
};
```

## `output.uniqueName`

`string`

전역을 사용할 때 여러 webpack 런타임이 충돌하지 않도록하는 webpack 빌드의 고유한 이름입니다. 기본값은 [`output.library`](/configuration/output/#outputlibrary) 이름 또는 컨텍스트에서 `package.json`의 패키지 이름입니다. 둘 다 찾을 수없는 경우 `''`으로 설정됩니다.

`output.uniqueName`은 고유한 전역을 생성하는 데 사용됩니다.

- [`output.chunkLoadingGlobal`](/configuration/output/#outputchunkloadingglobal)

**webpack.config.js**

```javascript
module.exports = {
  // ...
  output: {
    uniqueName: 'my-package-xyz',
  },
};
```

## `output.hashDigest`

`string = 'hex'`

해시를 생성할 때 사용하는 인코딩입니다. Node.JS의 모든 인코딩 [`hash.digest`](https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding)가 지원됩니다. 파일 이름에`'base64'`를 사용하면 알파벳에 `/` 문자가 있으므로 문제가 될 수 있습니다. 마찬가지로`'latin1'`은 모든 문자를 포함 할 수 있습니다.

## `output.hashDigestLength`

`number = 20`

사용할 해시 다이제스트의 접두사 길이입니다.

## `output.hashFunction`

`string = 'md4'` `function`

사용할 해싱 알고리즘입니다. Node.JS의 [`crypto.createHash`](https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm_options)의 모든 기능이 지원됩니다. `4.0.0-alpha2`부터 `hashFunction`은 커스텀 해시 함수의 생성자가 될 수 있습니다. 성능상의 이유로 비 암호화 해시 함수를 제공할 수 있습니다.

```javascript
module.exports = {
  //...
  output: {
    hashFunction: require('metrohash').MetroHash64,
  },
};
```

해싱 함수에서 `update` 및 `digest` 메소드를 사용할 수 있는지 확인하세요.

## `output.hashSalt`

Node.JS의 [`hash.update`](https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding)를 통해 해시를 업데이트하기 위해 선택적으로 사용할 수 있는 솔트입니다.

## `output.hotUpdateChunkFilename`

`string = '[id].[fullhash].hot-update.js'`

핫 업데이트 청크의 파일 이름을 사용자 지정합니다. 가능한 값에 대한 자세한 내용은 [`output.filename`](#outputfilename) 옵션을 참고하세요.

여기서 허용되는 유일한 자리 표시자는 `[id]`, `[fullhash]`이며 기본값은 다음과 같습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    hotUpdateChunkFilename: '[id].[fullhash].hot-update.js',
  },
};
```

T> 일반적으로 `output.hotUpdateChunkFilename`을 변경할 필요가 없습니다.

## `output.hotUpdateGlobal`

`string`

[`target`](/configuration/target/)이 핫 업데이트 로드에 JSONP를 사용하는 `'web'`으로 설정된 경우에만 사용됩니다.

핫 업데이트 청크를 비동기 적으로 로드하는 경우 사용되는 JSONP 함수입니다.

자세한 정보는 [`output.chunkLoadingGlobal`](#outputchunkloadingglobal)을 참고하세요.

## `output.hotUpdateMainFilename`

`string = '[runtime].[fullhash].hot-update.json'` `function`

주요 핫 업데이트 파일 이름을 사용자 지정합니다. `[fullhash]`, `[runtime]`을 자리 표시자로 사용할 수 있습니다.

T> 일반적으로 `output.hotUpdateMainFilename`을 변경할 필요가 없습니다.

## output.library

엔트리 포인트의 export를 내보내는 라이브러리를 설정합니다.

- Type: `string | string[] | object`

간단한 예제를 살펴 보겠습니다.

**webpack.config.js**

```js
module.exports = {
  // …
  entry: './src/index.js',
  output: {
    library: 'MyLibrary',
  },
};
```

`src/index.js` 엔트리에서 함수를 export했다고 가정하겠습니다.

```js
export function hello(name) {
  console.log(`hello ${name}`);
}
```

이제 변수 `MyLibrary`가 엔트리 파일의 export와 바인딩됩니다. 다음은 webpack 번들 라이브러리를 사용하는 방법입니다.

```html
<script src="https://example.org/path/to/my-library.js"></script>
<script>
  MyLibrary.hello('webpack');
</script>
```

위의 예에서 우리는 단일 엔트리 파일을 `entry`에 전달하고 있지만, webpack은 `array` 또는 `객체` 같이 [많은 종류의 엔트리 포인트](/configuration/entry-context/#entry)를 받아들일 수 있습니다.

1. `entry` 포인트로 `array`를 제공하면 배열의 마지막 항목만 내보냅니다.

   ```js
   module.exports = {
     // …
     entry: ['./src/a.js', './src/b.js'], // only exports in b.js will be exposed
     output: {
       library: 'MyLibrary',
     },
   };
   ```

2. `객체`가 `entry` 포인트로 제공되면 `library`의 `array` 구문을 사용하여 모든 항목을 내보낼 수 있습니다.

   ```js
   module.exports = {
     // …
     entry: {
       a: './src/a.js',
       b: './src/b.js',
     },
     output: {
       filename: '[name].js',
       library: ['MyLibrary', '[name]'], // name is a placeholder here
     },
   };
   ```

   `a.js`와 `b.js`가 둘 다 `hello`함수를 export 하는것으로 가정하면 다음은 라이브러리를 사용하는 방법입니다.

   ```html
   <script src="https://example.org/path/to/a.js"></script>
   <script src="https://example.org/path/to/b.js"></script>
   <script>
     MyLibrary.a.hello('webpack');
     MyLibrary.b.hello('webpack');
   </script>
   ```

   자세한 정보는 [이 예제](https://github.com/webpack/webpack/tree/master/examples/multi-part-library)를 참고하세요.

   엔트리 포인트 별로 라이브러리 옵션을 설정하려는 경우 위 설정이 예상대로 작동하지 않습니다. [각 엔트리 별 설정](/concepts/entry-points/#entrydescription-object)에 대한 방법은 아래와 같습니다.

   ```js
   module.exports = {
     // …
     entry: {
       main: {
         import: './src/index.js',
         library: {
           // `output.library`의 모든 옵션을 여기서 사용할 수 있습니다.
           name: 'MyLibrary',
           type: 'umd',
           umdNamedDefine: true,
         },
       },
       another: {
         import: './src/another.js',
         library: {
           name: 'AnotherLibrary',
           type: 'commonjs2',
         },
       },
     },
   };
   ```

### output.library.name

```js
module.exports = {
  // …
  output: {
    library: {
      name: 'MyLibrary',
    },
  },
};
```

라이브러리 이름을 설정할 수 있습니다.

- Type:
  ```ts
  string | string[] | {amd?: string, commonjs?: string, root?: string | string[]}
  ```

### output.library.type

라이브러리가 내보내지는 방식을 설정합니다.

- 타입: `string`

  기본적으로 포함되는 타입은 `'var'`, `'module'`, `'assign'`, `'assign-properties'`, `'this'`, `'window'`, `'self'`, `'global'`, `'commonjs'`, `'commonjs2'`, `'commonjs-module'`, `'amd'`, `'amd-require'`, `'umd'`, `'umd2'`, `'jsonp'` 그리고 `'system'`입니다. 다른 것들은 플러그인에 의해 추가될 수 있습니다.

다음 예에서는 `__entry_return_`을 사용하여 엔트리 포인트에서 반환한 값을 나타냅니다.

#### Expose a Variable

이 옵션은 번들이 포함된 범위에서 [`output.library.name`](#outputlibraryname)이 제공한 이름에 엔트리 포인트의 반환 값(export한 엔트리 포인트에 관계없이)을 할당합니다.

##### `type: 'var'`

```js
module.exports = {
  // …
  output: {
    library: {
      name: 'MyLibrary',
      type: 'var',
    },
  },
};
```

라이브러리가 로드되면 **엔트리 포인트의 반환 값이** 변수에 할당됩니다.

```javascript
var MyLibrary = _entry_return_;

// `MyLibrary`가 로드 된 별도의 스크립트
MyLibrary.doSomething();
```

##### `type: 'assign'`

```js
module.exports = {
  // …
  output: {
    library: {
      name: 'MyLibrary',
      type: 'assign',
    },
  },
};
```

이렇게 하면 기존 값을 다시 할당할 수 있는 암시적인 전역이 생성됩니다. 이 값은 주의해서 사용해야 합니다.

```javascript
MyLibrary = _entry_return_;
```

`MyLibrary`가 이전에 정의되지 않은 경우 라이브러리는 전역 범위로 설정됩니다.

##### `type: 'assign-properties'` <Badge text='5.16.0+' />

```js
module.exports = {
  // …
  output: {
    library: {
      name: 'MyLibrary',
      type: 'assign-properties',
    },
  },
};
```

[`type: 'assign'`](#type-assign)과 유사하지만 이미 존재하는 경우 `MyLibrary`를 재사용하므로 더 안전한 옵션입니다.

```js
// 존재하지 않는 경우에만 MyLibrary를 만듭니다.
MyLibrary = typeof MyLibrary === 'undefined' ? {} : MyLibrary;
// 그런 다음 반환 값을 MyLibrary에 복사합니다.
// Object.assign이 하는 동작과 같습니다.

// 예를 들어 다음과 같이 엔트리에 `hello`함수를 export합니다.
export function hello(name) {
  console.log(`Hello ${name}`);
}

// MyLibrary가 로드된 다른 스크립트에서
// 이렇게 `hello`함수를 실행할 수 있습니다.
MyLibrary.hello('World');
```

#### Expose Via Object Assignment

이 옵션은 [`output.library.name`](#outputlibraryname)에 정의된 이름 아래의 특정 객체에 엔트리 포인트의 반환 값(export한 엔트리 포인트에 관계없이)을 할당합니다.

##### `type: 'this'`

```js
module.exports = {
  // …
  output: {
    library: {
      name: 'MyLibrary',
      type: 'this',
    },
  },
};
```

**엔트리 포인트의 반환 값은** `output.library.name`이라는 속성 아래의 `this`에 할당됩니다. `this`의 의미는 당신에게 달려있습니다.

```javascript
this['MyLibrary'] = _entry_return_;

// 별도의 스크립트
this.MyLibrary.doSomething();
MyLibrary.doSomething(); // `this`가 window인 경우
```

##### `type: 'window'`

```js
module.exports = {
  // …
  output: {
    library: {
      name: 'MyLibrary',
      type: 'window',
    },
  },
};
```

**엔트리 포인트의 반환 값은** `output.library.name`값을 사용하여 `window` 객체에 할당됩니다.

```javascript
window['MyLibrary'] = _entry_return_;

window.MyLibrary.doSomething();
```

##### `type: 'global'`

```js
module.exports = {
  // …
  output: {
    library: {
      name: 'MyLibrary',
      type: 'global',
    },
  },
};
```

**엔트리 포인트의 반환 값은** `output.library.name`값을 사용하여 전역 개체에 할당됩니다. [`target`](/configuration/target/) 값에 따라 전역 객체가 `self`, `global` 또는 `globalThis`로 변경될 수 있습니다.

```javascript
global['MyLibrary'] = _entry_return_;

global.MyLibrary.doSomething();
```

##### `type: 'commonjs'`

```js
module.exports = {
  // …
  output: {
    library: {
      name: 'MyLibrary',
      type: 'commonjs',
    },
  },
};
```

**엔트리 포인트의 반환 값은** `output.library.name` 값을 사용하여 `exports`객체에 할당됩니다. 이름에서 알 수 있듯이 CommonJS 환경에서 사용됩니다.

```javascript
exports['MyLibrary'] = _entry_return_;

require('MyLibrary').doSomething();
```

W> `output.library.name`을 설정하지 않으면 엔트리 포인트에서 반환된 모든 속성이 주어진 객체에 할당됩니다. 기존 속성 이름에 대한 검사가 없습니다.

#### Module Definition Systems

이 옵션은 다양한 모듈 시스템과의 호환성을 보장하기 위한 헤더와 함께 제공되는 번들을 생성합니다. `output.library.name`은 `output.library.type`에서 다른 의미를 갖습니다.

##### `type: 'module'`

```js
module.exports = {
  // …
  experiments: {
    outputModule: true,
  },
  output: {
    library: {
      // 여기에 `name`을 지정하지 마세요.
      type: 'module',
    },
  },
};
```

ES 모듈을 출력합니다.

그러나 이 기능은 아직 실험적이며 완전히 지원되지 않으므로 [experiments.outputModule](/configuration/experiments/)을 활성화해야 합니다. 또한 [이 스레드](https://github.com/webpack/webpack/issues/2933#issuecomment-774253975)에서 개발 진행 상황을 추적할 수 있습니다.

##### `type: 'commonjs2'`

```js
module.exports = {
  // …
  output: {
    library: {
      // 여기에는 `name`이 없습니다.
      type: 'commonjs2',
    },
  },
};
```

**엔트리 포인트의 반환 값은** `module.exports`에 할당됩니다. 이름에서 알 수 있듯이 Node.js (CommonJS) 환경에서 사용됩니다.

```javascript
module.exports = _entry_return_;

require('MyLibrary').doSomething();
```

`type: commmonjs2`와 함께 `output.library.name`을 지정하면 엔트리 포인트의 반환 값이 `module.exports.[output.library.name]`에 할당됩니다.

T> CommonJS와 CommonJS2의 차이점이 궁금하신가요? 비슷하지만 webpack과 관련이 없는 부분에서 약간의 차이가 있습니다. 자세한 내용은 [이 이슈](https://github.com/webpack/webpack/issues/1114)를 참고하세요.

##### `type: 'amd'`

라이브러리를 AMD 모듈로 내보냅니다.

AMD 모듈은 일반적으로 RequireJS 또는 almond같은 호환 가능한 로더에서 제공하는 `define` 및 `require`와 같은 특정 속성으로 엔트리 청크(`<script>`태그에 의해 로드된 첫 번째 스크립트)를 정의해야합니다.

아래의 설정을 참고하세요.

```javascript
module.exports = {
  //...
  output: {
    library: {
      name: 'MyLibrary',
      type: 'amd',
    },
  },
};
```

생성된 출력은 `"MyLibrary"`라는 이름으로 정의됩니다. 예제는 아래와 같습니다.

```javascript
define('MyLibrary', [], function () {
  return _entry_return_;
});
```

번들은 script 태그의 일부로 포함될 수 있으며 번들은 다음과 같이 호출될 수 있습니다.

```javascript
require(['MyLibrary'], function (MyLibrary) {
  // 라이브러리로 무언가를 할 수 있습니다.
});
```

`output.library.name`이 정의되어 있지 않으면 아래의 코드가 대신 생성됩니다.

```javascript
define(function () {
  return _entry_return_;
});
```

이 번들은 예상대로 작동하지 않거나 almond 로더의 경우 `<script>`태그를 사용하여 직접 로드했을 때 전혀 작동하지 않습니다. 해당 파일의 실제 경로를 통해 RequireJS 호환 비동기 모듈 로더를 통해서만 작동하므로, 이 경우 `output.path` 및 `output.filename`이 서버에 직접 노출되는 경우 특정 설정에서 중요할 수 있습니다.

##### `type: 'amd-require'`

```javascript
module.exports = {
  //...
  output: {
    library: {
      name: 'MyLibrary',
      type: 'amd-require',
    },
  },
};
```

즉시 실행되는 AMD `require(dependencies, factory)`래퍼로 출력을 패키징합니다.

`'amd-require'` 타입을 사용하면 나중에 별도의 호출없이 AMD 디펜던시를 사용할 수 있습니다. `'amd'` 타입과 마찬가지로 이는 webpack 출력이 로드되는 환경에서 사용할 수 있는 적절한 [`require` 함수](https://github.com/amdjs/amdjs-api/blob/master/require.md)에 따라 다릅니다.

이 타입에서는 라이브러리 이름을 사용할 수 없습니다.

##### `type: 'umd'`

이렇게 하면 모든 모듈 정의 아래에 라이브러리가 내보내져서 CommonJS, AMD 및 전역 변수와 함께 작동 할 수 있습니다. 자세한 내용은 [UMD Repository](https://github.com/umdjs/umd)를 참고하세요.

이 경우 모듈 이름을 지정하려면 `library.name` 프로퍼티가 필요합니다.

```javascript
module.exports = {
  //...
  output: {
    library: {
      name: 'MyLibrary',
      type: 'umd',
    },
  },
};
```

출력은 다음과 같습니다.

```javascript
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
  else if (typeof exports === 'object') exports['MyLibrary'] = factory();
  else root['MyLibrary'] = factory();
})(global, function () {
  return _entry_return_;
});
```

`library.name`을 생략하면 [객체 할당 섹션](#expose-via-object-assignment)에 설명 된 대로 엔트리 포인트에서 반환된 모든 속성이 루트 객체에 직접 할당됩니다. 예제는 아래와 같습니다.

```javascript
module.exports = {
  //...
  output: {
    libraryTarget: 'umd',
  },
};
```

출력은 다음과 같습니다.

```javascript
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
  else {
    var a = factory();
    for (var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
  }
})(global, function () {
  return _entry_return_;
});
```

target마다 다른 이름을 설정하기 위해 `library.name`에 대한 객체를 설정할 수 있습니다.

```javascript
module.exports = {
  //...
  output: {
    library: {
      name: {
        root: 'MyLibrary',
        amd: 'my-library',
        commonjs: 'my-common-library',
      },
      type: 'umd',
    },
  },
};
```

##### `type: 'system'`

라이브러리를 [`System.register`](https://github.com/systemjs/systemjs/blob/master/docs/system-register.md)모듈로 내보냅니다. 이 기능은 [webpack 4.30.0](https://github.com/webpack/webpack/releases/tag/v4.30.0)에서 처음 출시되었습니다.

시스템 모듈은 webpack 번들이 실행될 때 브라우저에 전역 변수 `System`이 있어야합니다. `System.register`형식으로 컴파일하면 추가 설정없이 `System.import('/bundle.js')`를 수행하고 webpack 번들을 시스템 모듈 레지스트리에 로드할 수 있습니다.

```javascript
module.exports = {
  //...
  output: {
    library: {
      type: 'system',
    },
  },
};
```

출력은 다음과 같습니다.

```javascript
System.register([], function (__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {
  return {
    execute: function () {
      // ...
    },
  };
});
```

`output.library.type`을 `system`으로 설정하는 것 외에도 `output.library.name`을 설정에 추가하면 출력 번들은 `System.register`에 대한 인수로 라이브러리 이름을 갖게됩니다.

```javascript
System.register(
  'MyLibrary',
  [],
  function (__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {
    return {
      execute: function () {
        // ...
      },
    };
  }
);
```

#### Other Types

##### `type: 'jsonp'`

```js
module.exports = {
  // …
  output: {
    library: {
      name: 'MyLibrary',
      type: 'jsonp',
    },
  },
};
```

이것은 엔트리 포인트의 반환 값을 jsonp 래퍼로 래핑합니다.

```javascript
MyLibrary(_entry_return_);
```

라이브러리에 대한 디펜던시는 [`externals`](/configuration/externals/) 설정에 의해 정의됩니다.

T> `output.library.name` 및 `output.library.type`에 대한 자세한 내용은 [저자 라이브러리 가이드](/guides/author-libraries/)를 참고하세요.

### output.library.export

라이브러리로 노출되어야하는 export를 지정할 수 있습니다.

- Type: `string | string[]`

`undefined`가 기본값으로 설정되어 있으며 전체 네임스페이스 객체를 내보냅니다. 아래 예는 [`output.library.type: 'var'`](#type-var)를 사용할 때 이 설정의 효과를 보여줍니다.

```js
module.exports = {
  output: {
    library: {
      name: 'MyLibrary',
      type: 'var',
      export: 'default',
    },
  },
};
```

엔트리 포인트의 기본 export가 라이브러리 이름에 할당됩니다.

```js
// 엔트리에 default export가 있는 경우
var MyLibrary = _entry_return_.default;
```

`output.library.export`에도 배열을 전달할 수 있으며, 라이브러리 이름에 할당될 모듈의 경로로 해석됩니다.

```js
module.exports = {
  output: {
    library: {
      name: 'MyLibrary',
      type: 'var',
      export: ['default', 'subModule'],
    },
  },
};
```

아래는 라이브러리 코드입니다.

```js
var MyLibrary = _entry_return_.default.subModule;
```

### output.library.auxiliaryComment

UMD 래퍼에 주석을 추가합니다.

- Type: `string | { amd?: string, commonjs?: string, commonjs2?: string, root?: string }`

각 `umd` 타입에 대해 동일한 주석을 삽입하려면 `auxiliaryComment`를 문자열로 설정하세요.

```js
module.exports = {
  // …
  mode: 'development',
  output: {
    library: {
      name: 'MyLibrary',
      type: 'umd',
      auxiliaryComment: 'Test Comment',
    },
  },
};
```

아래와 같은 산출물이 생성됩니다.

```js
(function webpackUniversalModuleDefinition(root, factory) {
  //Test Comment
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  //Test Comment
  else if (typeof define === 'function' && define.amd) define([], factory);
  //Test Comment
  else if (typeof exports === 'object') exports['MyLibrary'] = factory();
  //Test Comment
  else root['MyLibrary'] = factory();
})(self, function () {
  return __entry_return_;
});
```

세부적인 제어를 위해 객체를 전달합니다.

```js
module.exports = {
  // …
  mode: 'development',
  output: {
    library: {
      name: 'MyLibrary',
      type: 'umd',
      auxiliaryComment: {
        root: 'Root Comment',
        commonjs: 'CommonJS Comment',
        commonjs2: 'CommonJS2 Comment',
        amd: 'AMD Comment',
      },
    },
  },
};
```

### output.library.umdNamedDefine

`boolean`

`output.library.type: "umd"`를 사용할 때 `output.library.umdNamedDefine`을 `true`로 설정하면 UMD 빌드의 AMD 모듈 이름이 지정됩니다. 그렇지 않으면 익명의 `define`이 사용됩니다.

```javascript
module.exports = {
  //...
  output: {
    library: {
      name: 'MyLibrary',
      type: 'umd',
      umdNamedDefine: true,
    },
  },
};
```

AMD 모듈은 다음과 같습니다.

```js
define('MyLibrary', [], factory);
```

## `output.libraryExport`

W> 지원을 중단 할 수 있으므로 `libraryExport`와 동일하게 작동하는 [output.library.export](#outputlibraryexport)를 사용하는 것이 좋습니다.

`string` `[string]`

`libraryTarget`을 통해 노출될 모듈을 구성합니다. 기본적으로 `undefined`이며 `libraryTarget`을 `''`같이 빈 문자열로 설정하면 동일한 동작이 적용됩니다(전체 네임 스페이스 객체를 export). 아래 예제는 `libraryTarget: 'var'`를 사용할 때 이 설정의 효과를 보여줍니다.

다음 설정이 지원됩니다.

`libraryExport: 'default'` - **엔트리 포인트의 default export** 가 라이브러리 target에 할당됩니다.

```javascript
// 엔트리에 `MyDefaultModule`의 default export가 있는 경우
var MyDefaultModule = _entry_return_.default;
```

`libraryExport: 'MyModule'` - **지정된 모듈** 이 라이브러리 target에 할당됩니다.

```javascript
var MyModule = _entry_return_.MyModule;
```

`libraryExport: ['MyModule', 'MySubModule']` - 배열은 라이브러리 target에 할당 될 **모듈 경로** 로 해석됩니다.

```javascript
var MySubModule = _entry_return_.MyModule.MySubModule;
```

위에 지정된 `libraryExport` 설정을 사용하면 결과 라이브러리를 다음과 같이 활용할 수 있습니다.

```javascript
MyDefaultModule.doSomething();
MyModule.doSomething();
MySubModule.doSomething();
```

## output.libraryTarget

`string = 'var'`

W> 나중에 `output.libraryTarget`에 대한 지원을 중단할 수 있으므로 대신 [`output.library.type`](#outputlibrarytype)을 사용하세요.

라이브러리를 내보내는 방식을 설정합니다. 다음 옵션 중 하나를 사용할 수 있습니다. 이 옵션은 [`output.library`](#outputlibrary)에 할당된 값과 함께 작동합니다. 다음 예에서는 [`output.library`](#outputlibrary)의 값이 `MyLibrary`로 설정되어 있다고 가정합니다.

T> 아래 예제 코드에서 `_entry_return_`은 엔트리 포인트에서 반환한 값입니다. 번들 자체에서는 엔트리 포인트에서 webpack에 의해 생성되는 함수의 출력입니다.

### Expose a Variable

이 옵션은 번들이 포함된 모든 범위에서 [`output.library`](#outputlibrary)에서 제공한 이름에 엔트리 포인트의 반환 값을 할당합니다.

#### `libraryTarget: 'var'`

W> [`output.library.type: 'var'`](#type-var)를 사용하는 것이 좋습니다.

라이브러리가 로드되면 **엔트리 포인트의 반환 값이** 변수에 할당됩니다.

```javascript
var MyLibrary = _entry_return_;

// In a separate script...
MyLibrary.doSomething();
```

#### `libraryTarget: 'assign'`

W> [`output.library.type: 'assign'`](#type-assign)을 사용하는 것이 좋습니다.

이렇게 하면 기존 값을 다시 할당할 수 있는 암시적인 전역이 생성됩니다. 주의해서 사용하세요.

```javascript
MyLibrary = _entry_return_;
```

`MyLibrary`가 이전에 정의되지 않은 경우 라이브러리는 전역 범위로 설정됩니다.

#### `libraryTarget: 'assign-properties'` <Badge text='5.16.0+' />

W> [output.library.type: 'assign-properties'`](#type-assign-properties)를 사용하는 것이 좋습니다.

반환 값이 있는 경우 대상 객체에 복사하고, 그렇지 않으면 먼저 대상 객체를 만듭니다.

```js
// 존재하지 않는 경우 대상 객체를 만듭니다.
MyLibrary = typeof MyLibrary === 'undefined' ? {} : MyLibrary;
// 그런 다음 반환 값을 MyLibrary에 복사하세요.
// Object.assign이 하는 동작과 같습니다.

// 예를 들어 다음과 같이 항목에 `hello` 함수를 export합니다.
export function hello(name) {
  console.log(`Hello ${name}`);
}

// MyLibrary를 실행하는 다른 스크립트에서
// 이렇게 `hello`함수를 실행할 수 있습니다.
MyLibrary.hello('World');
```

W> [`output.library`](#outputlibrary)에 빈 문자열은 유효하지 않습니다. 할당할 수 있는 유효한 식별자를 지정했는지 확인하세요.

### Expose Via Object Assignment

이 옵션은 엔트리 포인트의 반환 값(export한 엔트리 포인트에 관계없이)을 `output.library`에 정의된 이름으로 특정 객체에 할당합니다.

`output.library`에 빈 문자열이 할당된 경우 기본 동작은 엔트리 포인트에서 반환된 모든 프로퍼티가 다음 코드를 통해 `output.libraryTarget`에 정의된 대로 객체에 할당되는 것입니다.

```javascript
(function (e, a) {
  for (var i in a) {
    e[i] = a[i];
  }
})(output.libraryTarget, _entry_return_);
```

W> `output.library`를 설정하지 않으면 엔트리 포인트에서 반환한 모든 프로퍼티가 객체에 할당됩니다. 존재하는 프로퍼티 이름에 대한 검사는 하지 않습니다.

#### `libraryTarget: 'this'`

W> [`output.library.type: 'this'`](#type-this)를 사용하는 것이 좋습니다.

**엔트리 포인트의 반환 값은** `output.library`라는 프로퍼티 아래에 할당됩니다. `this`의 의미는 당신에게 달려있습니다.

```javascript
this['MyLibrary'] = _entry_return_;

// In a separate script...
this.MyLibrary.doSomething();
MyLibrary.doSomething(); // this가 window인 경우
```

#### `libraryTarget: 'window'`

W> [`output.library.type: 'window'`](#type-window)를 사용하는 것이 좋습니다.

**엔트리 포인트의 반환 값은** `output.library` 값을 사용하여 `window` 객체에 할당됩니다.

```javascript
window['MyLibrary'] = _entry_return_;

window.MyLibrary.doSomething();
```

#### `libraryTarget: 'global'`

W> [`output.library.type: 'global'`](#type-global)을 사용하는 것이 좋습니다.

**엔트리 포인트의 반환 값은** `output.library` 값을 사용하여 `global` 객체에 할당됩니다.

```javascript
global['MyLibrary'] = _entry_return_;

global.MyLibrary.doSomething();
```

#### `libraryTarget: 'commonjs'`

W> [`output.library.type: 'commonjs'`](#type-commonjs)를 사용하는 것이 좋습니다.

**엔트리 포인트의 반환 값은** `output.library` 값을 사용하여 `exports` 객체에 할당됩니다. 이름에서 알 수 있듯이 CommonJS 환경에서 사용됩니다.

```javascript
exports['MyLibrary'] = _entry_return_;

require('MyLibrary').doSomething();
```

### Module Definition Systems

이 옵션은 다양한 모듈 시스템과의 호환성을 보장하기 위해 헤더와 함께 제공되는 번들을 생성합니다. `output.library`는 `output.libraryTarget`에서 다른 의미를 갖습니다.

#### `libraryTarget: 'module'`

W> [`output.library.type: 'module'`](#type-module)을 사용하는 것이 좋습니다.

ES 모듈을 출력합니다. 미리 [experiments.outputModule](/configuration/experiments/)을 활성화해야 합니다.

이 기능은 아직 완전히 지원되지 않습니다. [이 스레드](https://github.com/webpack/webpack/issues/2933#issuecomment-774253975)에서 진행 상황을 추적하세요.

#### `libraryTarget: 'commonjs2'`

W> [`output.library.type: 'commonjs2'`](#type-commonjs2)를 사용하는 것이 좋습니다.

**엔트리 포인트의 반환 값은** `module.exports`에 할당됩니다. 이름에서 알 수 있듯이 CommonJS 환경에서 사용됩니다.

```javascript
module.exports = _entry_return_;

require('MyLibrary').doSomething();
```

`output.library`는 `output.libraryTarget`과 함께 사용할 수 없습니다. 자세한 내용은 [이 이슈](https://github.com/webpack/webpack/issues/11800)를 참고하세요.

T> CommonJS와 CommonJS2의 차이점이 궁금하신가요? 비슷하지만 webpack과 관련이 없는 약간의 차이가 있습니다. 자세한 내용은 [이 이슈](https://github.com/webpack/webpack/issues/1114)를 참고하세요.

#### `libraryTarget: 'amd'`

W> [`output.library.type: 'amd'`](#type-amd)를 사용하는 것이 좋습니다.

라이브러리를 AMD 모듈로 내보냅니다.

AMD 모듈은 일반적으로 RequireJS 또는 almond같은 호환 가능한 로더에서 제공하는 `define` 및 `require`와 같은 특정 속성으로 엔트리 청크(`<script>`태그에 의해 로드된 첫 번째 스크립트)를 정의해야합니다.

아래의 설정을 참고하세요.

```javascript
module.exports = {
  //...
  output: {
    library: 'MyLibrary',
    libraryTarget: 'amd',
  },
};
```

생성된 출력은 `"MyLibrary"`라는 이름으로 정의됩니다. 예제는 아래와 같습니다.

```javascript
define('MyLibrary', [], function () {
  return _entry_return_;
});
```

번들은 script 태그의 일부로 포함될 수 있으며 번들은 다음과 같이 호출될 수 있습니다.

```javascript
require(['MyLibrary'], function (MyLibrary) {
  // Do something with the library...
});
```

`output.library`가 정의되어 있지 않다면, 아래의 코드가 대신 생성됩니다.

```javascript
define([], function () {
  return _entry_return_;
});
```

이 번들은 예상대로 작동하지 않거나 almond 로더의 경우 `<script>`태그를 사용하여 직접 로드했을 때 전혀 작동하지 않습니다. 해당 파일의 실제 경로를 통해 RequireJS 호환 비동기 모듈 로더를 통해서만 작동하므로, 이 경우 `output.path` 및 `output.filename`이 서버에 직접 노출되는 경우 특정 설정에서 중요할 수 있습니다.

#### `libraryTarget: 'amd-require'`

W> [`output.library.type: 'amd-require'`](#type-amd-require)를 사용하는 것이 좋습니다.

이 옵션은 즉시 실행되는 AMD `require(dependencies, factory)`래퍼로 출력을 패키징합니다.

`'amd-require'`를 사용하면 나중에 별도의 호출없이 AMD 디펜던시를 사용할 수 있습니다. `'amd'`와 마찬가지로 이는 webpack 출력이 로드되는 환경에서 사용할 수 있는 적절한 [`require` 함수](https://github.com/amdjs/amdjs-api/blob/master/require.md)에 따라 다릅니다.

`'amd-require'`를 사용하면 라이브러리 이름이 무시됩니다.

#### `libraryTarget: 'umd'`

W> [`output.library.type: 'umd'`](#type-umd)를 사용하는 것이 좋습니다.

이렇게 하면 모든 모듈 정의 아래에 라이브러리가 내보내져서 CommonJS, AMD 및 전역 변수와 함께 작동 할 수 있습니다. 자세한 내용은 [UMD Repository](https://github.com/umdjs/umd)를 참고하세요.

이 경우 모듈 이름을 지정하려면 `library` 프로퍼티가 필요합니다.

```javascript
module.exports = {
  //...
  output: {
    library: 'MyLibrary',
    libraryTarget: 'umd',
  },
};
```

출력은 다음과 같습니다.

```javascript
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
  else if (typeof exports === 'object') exports['MyLibrary'] = factory();
  else root['MyLibrary'] = factory();
})(typeof self !== 'undefined' ? self : this, function () {
  return _entry_return_;
});
```

`library`를 생략하면 [객체 할당 섹션](#expose-via-object-assignment)에 설명 된 대로 엔트리 포인트에서 반환된 모든 속성이 루트 객체에 직접 할당됩니다. 예제는 아래와 같습니다.

```javascript
module.exports = {
  //...
  output: {
    libraryTarget: 'umd',
  },
};
```

출력은 다음과 같습니다.

```javascript
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
  else {
    var a = factory();
    for (var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
  }
})(typeof self !== 'undefined' ? self : this, function () {
  return _entry_return_;
});
```

webpack 3.1.0부터는 target마다 다른 이름을 설정하기 위해 `library`에 대한 객체를 설정할 수 있습니다.

```javascript
module.exports = {
  //...
  output: {
    library: {
      root: 'MyLibrary',
      amd: 'my-library',
      commonjs: 'my-common-library',
    },
    libraryTarget: 'umd',
  },
};
```

#### `libraryTarget: 'system'`

W> [`output.library.type: 'system'`](#type-system)을 사용하는 것이 좋습니다.

라이브러리를 [`System.register`](https://github.com/systemjs/systemjs/blob/master/docs/system-register.md)모듈로 내보냅니다. 이 기능은 [webpack 4.30.0](https://github.com/webpack/webpack/releases/tag/v4.30.0)에서 처음 출시되었습니다.

시스템 모듈은 webpack 번들이 실행될 때 브라우저에 전역 변수 `System`이 있어야 합니다. `System.register`형식으로 컴파일하면 추가 설정없이 `System.import('/bundle.js')`를 수행하고 webpack 번들을 시스템 모듈 레지스트리에 로드할 수 있습니다.

```javascript
module.exports = {
  //...
  output: {
    libraryTarget: 'system',
  },
};
```

출력은 다음과 같습니다.

```javascript
System.register([], function (_export) {
  return {
    setters: [],
    execute: function () {
      // ...
    },
  };
});
```

`output.libraryTarget`을 `system`으로 설정하는 것 외에도 `output.library`를 설정에 추가하면 출력 번들은 `System.register`에 대한 인수를 라이브러리 이름으로 갖게됩니다.

```javascript
System.register('my-library', [], function (_export) {
  return {
    setters: [],
    execute: function () {
      // ...
    },
  };
});
```

`__system_context__`를 통해 [SystemJS 컨텍스트](https://github.com/systemjs/systemjs/blob/master/docs/system-register.md#format-definition)에 접근할 수 있습니다.

```javascript
// 현재 SystemJS 모듈의 URL을 기록합니다.
console.log(__system_context__.meta.url);

// 현재 SystemJS 모듈의 URL을 parentUrl로 사용하여 SystemJS 모듈을 가져옵니다.
__system_context__.import('./other-file.js').then((m) => {
  console.log(m);
});
```

### Other Targets

#### `libraryTarget: 'jsonp'`

W> [`output.library.type: 'jsonp'`](#type-jsonp)를 사용하는 것이 좋습니다.

이것은 엔트리 포인트의 반환 값을 jsonp 래퍼로 래핑합니다.

```javascript
MyLibrary(_entry_return_);
```

라이브러리에 대한 디펜던시는 [`externals`](/configuration/externals/) 설정에 의해 정의됩니다.

## `output.importFunctionName`

`string = 'import'`

네이티브 `import()`함수의 이름입니다. [`dynamic-import-polyfill`](https://github.com/GoogleChromeLabs/dynamic-import-polyfill)같은 폴리필에 사용할 수 있습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    importFunctionName: '__import__',
  },
};
```

## `output.path`

`string = path.join(process.cwd(), 'dist')`

**절대** 경로로 출력 디렉토리를 설정합니다.

**webpack.config.js**

```javascript
const path = require('path');

module.exports = {
  //...
  output: {
    path: path.resolve(__dirname, 'dist/assets'),
  },
};
```

이 파라미터의 `[fullhash]`는 컴파일의 해시로 대체됩니다. 자세한 내용은 [캐싱 가이드](/guides/caching/)를 참고하세요.

## `output.pathinfo`

`boolean=true` `string: 'verbose'`

포함된 모듈에 대한 정보를 주석으로 번들에 포함하도록 webpack에 지시합니다. 이 옵션의 기본값은 `development`에서 `true`이고 `production` [모드](/configuration/mode/)에서는 `false`입니다. `'verbose'`는 export, 런타임 요구 사항 및 bailouts와 같은 더 많은 정보를 보여줍니다.

W> 이 주석이 제공하는 데이터는 개발 중에 생성된 코드를 읽을 때는 유용하지만 프로덕션에서 사용해서는 **안 됩니다**.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    pathinfo: true,
  },
};
```

T> 또한 생성된 번들에 트리 쉐이킹에 대한 정보를 추가합니다.

## `output.publicPath`

`string` `function`

이것은 온 디맨드 로드를 사용하거나 이미지, 파일 등과 같은 외부 리소스를 로드할 때 중요한 옵션입니다. 잘못된 값을 지정하면 리소스를 로드하는 동안 404 오류가 발생합니다.

이 옵션은 브라우저에서 참조될 때 출력 디렉토리의 **공용 URL** 을 지정합니다. 상대 URL은 HTML 페이지 또는`<base>`태그를 기준으로 확인됩니다. 서버 상대 URL, 프로토콜 상대 URL 또는 절대 URL도 가능하며 때로는 필요합니다(CDN에서 애셋을 호스팅 하는 경우).

옵션의 값은 런타임 또는 로더가 생성한 모든 URL에 접두사로 추가됩니다. 이 때문에 **이 옵션의 값은 대부분의 경우 `/`** 로 끝납니다.

간단한 규칙: HTML 페이지에서 [`output.path`](#outputpath) URL을 볼 수 있습니다.

**webpack.config.js**

```javascript
const path = require('path');

module.exports = {
  //...
  output: {
    path: path.resolve(__dirname, 'public/assets'),
    publicPath: 'https://cdn.example.com/assets/',
  },
};
```

이 설정의 경우 다음과 같습니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    publicPath: '/assets/',
    chunkFilename: '[id].chunk.js',
  },
};
```

청크에 대한 요청은 `/assets/4.chunk.js`와 같습니다.

HTML을 출력하는 로더는 다음과 같이 출력할 수 있습니다.

```html
<link href="/assets/spinner.gif" />
```

또는 CSS에서 이미지를 로드할 때는 다음과 같습니다.

```css
background-image: url(/assets/spinner.gif);
```

webpack-dev-server는 `publicPath`에서 힌트를 가져 와서 출력 파일을 제공할 위치를 결정합니다.

이 파라미터의 `[fullhash]`는 컴파일의 해시로 대체됩니다. 자세한 내용은 [캐싱 가이드](/guides/caching)를 참고하세요.

Examples:

```javascript
module.exports = {
  //...
  output: {
    // 아래 중 하나
    publicPath: 'auto', // `import.meta.url`, `document.currentScript`, `<script />` 또는 `self.location`에서 public path를 자동으로 결정합니다.
    publicPath: 'https://cdn.example.com/assets/', // CDN (항상 HTTPS)
    publicPath: '//cdn.example.com/assets/', // CDN (같은 프로토콜)
    publicPath: '/assets/', // 서버의 상대 경로
    publicPath: 'assets/', // HTML 페이지의 상대 경로
    publicPath: '../assets/', // HTML 페이지의 상대 경로
    publicPath: '', // HTML 페이지의 상대 경로 (같은 디렉터리)
  },
};
```

컴파일 타임에 출력 파일의 `publicPath`를 알 수 없는 경우 공백으로 남겨두고 런타임에 [자유 변수](https://stackoverflow.com/questions/12934929/What-are-free-variables) `__webpack_public_path__`를 사용하여 엔트리 파일에서 동적으로 설정할 수 있습니다.

```javascript
__webpack_public_path__ = myRuntimePublicPath;

// 애플리케션 엔트리의 나머지
```

`__webpack_public_path__`에 대한 자세한 정보는 [이 논의](https://github.com/webpack/webpack/issues/2776#issuecomment-233208623)를 참고하세요.

T> `web`과 `web-worker`가 target인 경우 `output.publicPath`의 기본값은 `'auto'`입니다.

## output.scriptType

`string: 'module' | 'text/javascript'` `boolean = false`

이 옵션을 사용하면 `<script type="module"...>`과 같은 커스텀 스크립트 타입으로 비동기 청크를 로드할 수 있습니다.

T> [`output.module`](#outputmodule)이 `true`로 설정되어 있다면 `output.scriptType`의 기본값은 `false`대신 `'module'`로 설정될 것 입니다.

```javascript
module.exports = {
  //...
  output: {
    scriptType: 'module',
  },
};
```

## `output.sourceMapFilename`

`string = '[file].map[query]'`

소스맵 이름을 짓는 방법을 설정합니다. [`devtool`](/configuration/devtool/)이 출력 파일을 쓰는 `'source-map'`으로 설정된 경우에만 적용됩니다.

[`output.filename`](#outputfilename)의 `[name]`, `[id]`, `[fullhash]` 그리고 `[chunkhash]` substitution을 사용할 수 있습니다. 그 외에도 [템플릿 문자열](/configuration/output/#template-strings)의 파일 이름 수준 아래에 나열된 substitution을 사용할 수 있습니다.

## `output.sourcePrefix`

`string = ''`

출력 번들의 각 줄에 대한 접두사를 변경합니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    sourcePrefix: '\t',
  },
};
```

T> 어떤 종류의 들여 쓰기를 사용하면 번들이 더 예쁘게 보이지만, 여러 줄의 문자열에서 문제가 발생합니다.

T> 일반적으로 `output.sourcePrefix`를 변경할 필요가 없습니다.

## output.strictModuleErrorHandling

성능 비용으로 EcmaScript 모듈 사양에 따라 모듈 로딩시에 발생하는 오류를 처리합니다.

- 타입: `boolean`
- 가능한 버전: 5.25.0+

```javascript
module.exports = {
  //...
  output: {
    strictModuleErrorHandling: true,
  },
};
```

## output.strictModuleExceptionHandling

W> 지원이 중단되었습니다.
대신에 [`output.strictModuleErrorHandling`](#outputstrictmoduleerrorhandling)을 사용하세요.

`boolean = false`

`require` 될 때 예외가 발생하면 webpack에게 모듈 인스턴스 캐시(`require.cache`)에서 모듈을 제거하도록 지시합니다.

성능상의 이유로 기본값은 `false`입니다.

`false`로 설정하면 모듈이 캐시에서 제거되지 않으므로 첫 번째 `require`호출에서만 예외가 발생합니다(node.js와 호환되지 않음).

예를 들어 `module.js`를 고려해봅시다.

```javascript
throw new Error('error');
```

`strictModuleExceptionHandling`을 `false`로 설정하면 첫 번째 `require`만 예외가 발생합니다.

```javascript
// strictModuleExceptionHandling = false 로 설정
require('module'); // <- 예외 발생
require('module'); // <- 예외 발생하지 않음
```

대신 `strictModuleExceptionHandling`을 `true`로 설정하면 이 모듈의 모든 `require`에서 예외가 발생합니다.

```javascript
// strictModuleExceptionHandling = true 로 설정
require('module'); // <- 예외 발생
require('module'); // <- 예외 발생
```

## `output.trustedTypes`

`boolean = false` `string` `object`

<Badge text="5.37.0+" />

[신뢰할 수 있는 타입](https://web.dev/trusted-types) 호환성을 제어합니다. 활성화되면 webpack은 신뢰할 수 있는 타입 지원을 감지하고 지원하는 경우 신뢰할 수 있는 타입 정책을 사용하여 동적으로 로드하는 스크립트 URL을 생성합니다. 애플리케이션이 [`require-trusted-types-for`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/require-trusted) 콘텐츠 보안 정책 지침에 따라 실행될 때 사용합니다.

기본값은 `false`입니다(호환성 없음, 스크립트 URL은 문자열).

- `true`로 설정하면 webpack은 [`output.uniqueName`](#outputuniquename)을 신뢰할 수 있는 타입 정책 이름으로 사용합니다.
- 비어 있지 않은 문자열로 설정하면 해당 값이 정책 이름으로 사용됩니다.
- 객체로 설정하면 객체의 `policyName`프로퍼티에서 정책 이름을 가져옵니다.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    //...
    trustedTypes: {
      policyName: 'my-application#webpack',
    },
  },
};
```

## `output.umdNamedDefine`

W> [`output.library.umdNamedDefine`](#outputlibraryumdnameddefine)을 사용하는 것이 좋습니다.

`boolean`

`libraryTarget: "umd"`를 사용할 때 `output.umdNamedDefine`을 `true`로 설정하면 UMD 빌드의 AMD 모듈 이름이 지정됩니다. 그렇지 않으면 익명의 `define`이 사용됩니다.

```javascript
module.exports = {
  //...
  output: {
    umdNamedDefine: true,
  },
};
```

## `output.workerChunkLoading`

`string: 'require' | 'import-scripts' | 'async-node' | 'import' | 'universal'` `boolean: false`

새로운 옵션 `workerChunkLoading`은 worker의 청크 로드를 제어합니다.

T> 이 옵션의 기본값은 `target` 설정에 따라 다릅니다. 자세한 내용은 [webpack default에서](https://github.com/webpack/webpack/blob/master/lib/config/defaults.js) `"workerChunkLoading"`을 검색하세요.

**webpack.config.js**

```javascript
module.exports = {
  //...
  output: {
    workerChunkLoading: false,
  },
};
```

## `output.futureEmitAssets`

`boolean = false`

webpack에 애셋 방출 로직의 미래 버전을 사용하도록 지시하여 방출 후 애셋의 메모리를 해제할 수 있습니다. 애셋이 방출된 후에도 여전히 읽을 수 있다고 가정하는 플러그인이 손상될 수 있습니다.

W> `output.futureEmitAssets`은 webpack v5.0.0 에서 제거되고 기본 동작이 될 예정입니다.

```javascript
module.exports = {
  //...
  output: {
    futureEmitAssets: true,
  },
};
```

## `output.wasmLoading`

`boolean = false` `string`

WebAssembly 모듈을 로드하는 방법을 설정하는 옵션입니다. 기본적으로 포함된 메소드는 `'fetch'` (web/WebWorker), `'async-node'` (Node.js)이고 다른 것들도 플러그인에 의해 추가될 수 있습니다.

기본값은 다른 [`target`](/configuration/target/)의 영향을 받을 수 있습니다.

- [`target`](/configuration/target/)이 `'web'`, `'webworker'`, `'electron-renderer'` 또는 `'node-webkit'`으로 설정된 경우 기본값은 `'fetch'`입니다.
- [`target`](/configuration/target/)이 `'node'`, `'async-node'`, `'electron-main'` 또는 `'electron-preload'`로 설정된 경우 기본값은 `'async-node'`입니다.

```javascript
module.exports = {
  //...
  output: {
    wasmLoading: 'fetch',
  },
};
```

## `output.iife`

`boolean = true`

내보낸 코드에 [IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE) 래퍼를 추가하도록 webpack에 지시합니다.

```javascript
module.exports = {
  //...
  output: {
    iife: true,
  },
};
```

## `output.module`

`boolean = false`

모듈 타입으로 JavaScript 파일을 출력합니다. 실험적 기능이므로 기본적으로 비활성화되어 있습니다.

활성화되면 webpack은 내부적으로 [`output.iife`](#outputiife)를 `false`로, [`output.scriptType`](#outputscripttype)을 `'module'`로, `terserOptions.module`을 `true`로 설정합니다.

다른 사용자가 사용할 라이브러리를 컴파일하기 위해 webpack을 사용하는 경우 `output.module`이 `true` 일 때 [`output.libraryTarget`](#librarytarget-module)을 `'module'`로 설정해야 합니다.

```javascript
module.exports = {
  //...
  experiments: {
    outputModule: true,
  },
  output: {
    module: true,
  },
};
```

W> `output.module`은 실험적 기능이며 [`experiments.outputModule`](/configuration/experiments/#experiments)을 `true`로 설정해야만 활성화 할 수 있습니다.
